# å¹¶å‘ç¼–ç¨‹ï¼ˆä¸€ï¼‰


[ã€ŠçŽ°ä»£C&#43;&#43;å¹¶å‘ç¼–ç¨‹æ•™ç¨‹ã€‹](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/) â€”â€” C&#43;&#43;å¹¶å‘ç¼–ç¨‹å­¦ä¹ ç¬”è®°ï¼ˆä¸€ï¼‰

&lt;!--more--&gt;

## å¯åŠ¨çº¿ç¨‹

```cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;

void hello() {
    printf(&#34;hello world!\n&#34;);
}

int main() {
    std::thread my_thread(hello);

}
```

å¯ä»¥ä¼ å…¥å‡½æ•°å¯¹è±¡ï¼Œå¦‚ä¸Šä¾‹æ‰€ç¤ºã€‚ä¹Ÿå¯ä»¥ä¼ å…¥ç±»æˆ–è€…å…¶ä»–é‡è½½äº† `()` ï¼ˆcallableï¼‰è¿ç®—ç¬¦çš„å¯¹è±¡ï¼Œä¾‹å¦‚ï¼š

```cpp
class task {
public:
    void operator()() const {
        do_something();
        do_something_else();
    }
};

task f;
std::thread my_thread(f);
```

ä½†è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸ªé—®é¢˜ï¼Œç”±äºŽ C&#43;&#43; çš„è¯­æ³•é—®é¢˜ï¼Œæœ‰æ—¶ä¼šé€ æˆæ­§ä¹‰ï¼Œä¾‹å¦‚ï¼š

```cpp
std::thread my_thread(task());  // è¿™ä¼šè¢«è®¤ä¸ºæ˜¯å£°æ˜Žäº†ä¸€ä¸ªè¿”å›žå€¼ä¸º thread çš„ï¼Œåä¸º my_thread çš„å‡½æ•°
```

è¿™é‡Œæœ€å¥½ä½¿ç”¨ `{}` è¿ç®—ç¬¦æ¥åˆ›å»ºä¸€ä¸ª `thread` å¯¹è±¡ï¼Œå¦‚ï¼š `std::thread my_thread{task()}`ã€‚åŒæ—¶ä¹Ÿå¯ä»¥ç”¨åŒ¿åå‡½æ•°ï¼ˆlambdaè¡¨è¾¾å¼ï¼‰æ¥åˆ›å»ºçº¿ç¨‹ï¼š

```cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;

int main() {
    std::thread thread{ [] {std::cout &lt;&lt; &#34;Hello World!\n&#34;; } };
    thread.join();
}
```

&gt; [!NOTE] å½“ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡åˆ›å»ºæ—¶ï¼ˆå³ `std::thread` å¯¹è±¡æž„é€ æ—¶ï¼‰å°±å¼€å§‹æ‰§è¡Œä¼ å…¥çš„å‡½æ•° `f` äº†ã€‚

## çº¿ç¨‹ç®¡ç†

å¯åŠ¨çº¿ç¨‹åŽï¼ˆæž„é€  `std::thread` å¯¹è±¡ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸç»“æŸä¹‹å‰ï¼Œå³  `std::thread::~thread` è°ƒç”¨ä¹‹å‰ï¼Œå†³å®šå®ƒçš„æ‰§è¡Œç­–ç•¥ï¼ŒåŒ…æ‹¬ `join()` å’Œ `detach()`ã€‚

### `join()`

å…¶ä¸­ `join()` è¡¨ç¤ºå°†é˜»å¡žå…³è”çš„çº¿ç¨‹ï¼Œç›´è‡³æ‰§è¡Œå®Œæ¯•ã€‚å†…éƒ¨å®žçŽ°ä¼šè®© `std::thread::joinable()` è¿”å›ž `false`ã€‚å¦åˆ™ä¼šè¿”å›ž `true`ï¼Œæ‰§è¡Œ `std::terminate()`ã€‚

### `detach()`

æ‰§è¡Œäº† `detach()` åŽï¼Œè¡¨ç¤ºçº¿ç¨‹å¯¹è±¡æ”¾å¼ƒäº†å¯¹çº¿ç¨‹èµ„æºçš„æ‰€æœ‰æƒï¼Œå…è®¸æ­¤çº¿ç¨‹çš„ç‹¬ç«‹è¿è¡Œï¼Œåœ¨çº¿ç¨‹é€€å‡ºæ—¶é‡Šæ”¾æ‰€æœ‰åˆ†é…çš„èµ„æºã€‚é€šå¸¸ä¸å»ºè®®ä½¿ç”¨ `detach()`ï¼Œå¯ä»¥ç”¨ `join()` æ›¿ä»£ã€‚

å¯ä»¥æä¾›ä¸€ä¸ªç±»ï¼ŒRAIIï¼ˆResource Acquisition Initilizationï¼‰åœ°ç¡®ä¿çº¿ç¨‹æ‰§è¡Œå®Œæˆï¼Œçº¿ç¨‹å¯¹è±¡æ­£å¸¸æžæž„é‡Šæ”¾èµ„æºï¼š

```cpp
class thread_guard {
    std::thread&amp; m_t;
public:
    explicit thread_guard(std::thread&amp; t) : m_t{ t } {}
    ~thread_guard() {
        std::puts(&#34;æžæž„&#34;);     // æ‰“å°æ—¥å¿— ä¸ç”¨åœ¨ä¹Ž
        if (m_t.joinable()) { // çº¿ç¨‹å¯¹è±¡å½“å‰å…³è”äº†æ´»è·ƒçº¿ç¨‹
            m_t.join();
        }
    }
    thread_guard(const thread_guard&amp;) = delete;
    thread_guard&amp; operator=(const thread_guard&amp;) = delete;
};
void f() {
    int n = 0;
    std::thread t{ func{n},10 };
    thread_guard g(t);
    f2(); // å¯èƒ½æŠ›å‡ºå¼‚å¸¸
}
```

## ä¼ é€’å‚æ•°

å‘å¯è°ƒç”¨å¯¹è±¡ä¼ é€’å‚æ•°ï¼Œåªéœ€è¦å°†è¿™äº›å‚æ•°ä½œä¸º `std::thread` çš„æž„é€ å‚æ•°å³å¯ã€‚
&gt; [!NOTE] éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™äº›å‚æ•°ä¼šå¤åˆ¶åˆ°æ–°çº¿ç¨‹çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå³ä½¿å‡½æ•°ä¸­çš„å‚æ•°æ˜¯å¼•ç”¨ï¼Œä¾ç„¶å®žé™…æ˜¯å¤åˆ¶ã€‚

```cpp
void f(int, const int&amp; a);

int n = 1;
std::thread t{ f, 3, n };
```

çº¿ç¨‹å¯¹è±¡ t çš„æž„é€ æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯è¿™ä¸ª n å®žé™…ä¸Šå¹¶æ²¡æœ‰æŒ‰å¼•ç”¨ä¼ é€’ï¼Œè€Œæ˜¯æŒ‰å€¼å¤åˆ¶çš„ã€‚å¦‚æžœæˆ‘ä»¬çš„ f çš„å½¢å‚ç±»åž‹ä¸æ˜¯ const çš„å¼•ç”¨ï¼Œåˆ™ä¼šäº§ç”Ÿä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚å¯ä»¥ç”¨æ ‡å‡†åº“çš„ `std::ref`ã€`std::cref` å‡½æ•°æ¨¡ç‰ˆã€‚

```cpp
void f(int, int&amp; a) {
    std::cout &lt;&lt; &amp;a &lt;&lt; &#39;\n&#39;;
}

int main() {
    int n = 1;
    std::cout &lt;&lt; &amp;n &lt;&lt; &#39;\n&#39;;
    std::thread t { f, 3, std::ref(n) };
    t.join();
}
```

## å…±äº«æ•°æ®

æˆ‘ä»¬éƒ½çŸ¥é“çº¿ç¨‹é€šä¿¡çš„æ–¹å¼æœ‰==ä¸´ç•ŒåŒºã€äº’æ–¥é‡ã€ä¿¡å·é‡ã€æ¡ä»¶å˜é‡ã€è¯»å†™é”==ï¼š

&gt; 1. ä¸´ç•ŒåŒºï¼šæ¯ä¸ªçº¿ç¨‹ä¸­è®¿é—®ä¸´ç•Œèµ„æºçš„é‚£æ®µä»£ç ç§°ä¸ºä¸´ç•ŒåŒºï¼ˆCritical Sectionï¼‰ï¼ˆä¸´ç•Œèµ„æºæ˜¯ä¸€æ¬¡ä»…å…è®¸ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨çš„å…±äº«èµ„æºï¼‰ã€‚æ¯æ¬¡åªå‡†è®¸ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºï¼Œè¿›å…¥åŽä¸å…è®¸å…¶ä»–çº¿ç¨‹è¿›å…¥ã€‚ä¸è®ºæ˜¯ç¡¬ä»¶ä¸´ç•Œèµ„æºï¼Œè¿˜æ˜¯è½¯ä»¶ä¸´ç•Œèµ„æºï¼Œå¤šä¸ªçº¿ç¨‹å¿…é¡»äº’æ–¥åœ°å¯¹å®ƒè¿›è¡Œè®¿é—®ã€‚åœ¨ä¸´ç•ŒåŒºä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦è®²çš„äº’æ–¥é‡ï¼ˆMutexï¼‰
&gt; 2. äº’æ–¥é‡ï¼šé‡‡ç”¨äº’æ–¥å¯¹è±¡æœºåˆ¶ï¼Œåªæœ‰æ‹¥æœ‰äº’æ–¥å¯¹è±¡çš„çº¿ç¨‹æ‰å¯ä»¥è®¿é—®ã€‚å› ä¸ºäº’æ–¥å¯¹è±¡åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥å¯ä»¥ä¿è¯å…¬å…±èµ„æºä¸ä¼šè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®ã€‚
&gt; 3. ä¿¡å·é‡ï¼šè®¡æ•°å™¨ï¼Œå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€ä¸ªèµ„æºã€‚
&gt; 4. æ¡ä»¶å˜é‡ï¼šé€šè¿‡æ¡ä»¶å˜é‡é€šçŸ¥æ“ä½œçš„æ–¹å¼æ¥ä¿æŒå¤šçº¿ç¨‹åŒæ­¥ã€‚
&gt; 5. è¯»å†™é”ï¼šè¯»å†™é”ä¸Žäº’æ–¥é‡ç±»ä¼¼ã€‚ä½†äº’æ–¥é‡è¦ä¹ˆæ˜¯é”ä½çŠ¶æ€ï¼Œè¦ä¹ˆå°±æ˜¯ä¸åŠ é”çŠ¶æ€ã€‚è¯»å†™é”ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹å†™ï¼Œä½†å…è®¸ä¸€æ¬¡å¤šä¸ªçº¿ç¨‹è¯»ï¼Œè¿™æ ·æ•ˆçŽ‡å°±æ¯”äº’æ–¥é”è¦é«˜ã€‚

å¦‚æžœæœ‰ä»¥ä¸‹æƒ…å†µï¼Œå‡ºçŽ°==æ•°æ®ç«žäº‰==æƒ…å†µã€‚

```cpp
std::vector&lt;int&gt; v;

void f() { v.emplace_back(1); }
void f2() { v.erase(v.begin()); }

int main() {
    std::thread t{ f };
    std::thread t2{ f2 };
    t.join();
    t2.join();
    std::cout &lt;&lt; v.size() &lt;&lt; &#39;\n&#39;;  // æœ‰æ—¶å‡ºçŽ°æ®µé”™è¯¯ï¼Œæœ‰æ—¶è¾“å‡º0ï¼Œä¸ç¨³å®šçš„è¾“å‡ºç»“æžœ
}
```

è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç”¨==äº’æ–¥é‡==æ¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚

```cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::mutex m;
std::vector&lt;int&gt; v;

void f() {
    m.lock();
    v.emplace_back(1);
    m.unlock();
}

void f2() {
    m.lock();
    v.erase(v.begin());
    m.unlock();
}

int main() {
    std::thread t{ f };
    std::thread t2{ f2 };
    t.join();
    t2.join();
    std::cout &lt;&lt; v.size() &lt;&lt; &#39;\n&#39;;  // ç¨³å®šè¾“å‡º0
}
```

å¦å¤–ä¸€ä¸ªä¾‹å­ï¼Œä½¿ç”¨ mutex äº’æ–¥é‡å‰ï¼š

```cpp
void f() {
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &#39;\n&#39;;
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0; i &lt; 10; &#43;&#43;i)
        threads.emplace_back(f);

    for (auto&amp; thread : threads)
        thread.join();
}
```

&gt; [!NOTE] è¿™é‡Œæœ‰ä¸€ä¸ªç‚¹ï¼Œæ­£å¥½è¯´æ˜Žä¸€ä¸‹ `push_back()` å’Œ `emplace_back()` çš„åŒºåˆ«
&gt; 1. å¦‚æžœè¦ç”¨ `push_back`ï¼Œåˆ™éœ€è¦å…ˆæž„é€ ä¸€ä¸ª thread ä¸´æ—¶å¯¹è±¡ï¼š`threads.push_back(std::thread(f));`
&gt; 2. è€Œå¦‚æžœç”¨ `emplace_back`ï¼Œè¯¥æ–¹æ³•å…è®¸åœ¨ `vector` æœ«å°¾ç›´æŽ¥æž„é€ å¯¹è±¡ï¼Œè€Œæ— éœ€åˆ›å»ºä¸´æ—¶å¯¹è±¡ã€‚å®ƒæŽ¥å—æž„é€ å‡½æ•°çš„å‚æ•°ï¼Œå¹¶åœ¨é€‚å½“çš„ä½ç½®ç›´æŽ¥è°ƒç”¨æž„é€ å‡½æ•°ã€‚è¿™æ ·å¯ä»¥å‡å°‘ä¸å¿…è¦çš„å¯¹è±¡åˆ›å»ºå’Œç§»åŠ¨æ“ä½œï¼Œæé«˜æ€§èƒ½ï¼š`threads.emplace_back(f);`

ä½¿ç”¨åŽï¼š

```cpp
#include &lt;mutex&gt; // å¿…è¦æ ‡å¤´
std::mutex m;

void f() {
    m.lock();
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &#39;\n&#39;;
    m.unlock();
}

int main() {
    std::vector&lt;std::thread&gt;threads;
    for (std::size_t i = 0; i &lt; 10; &#43;&#43;i)
        threads.emplace_back(f);

    for (auto&amp; thread : threads)
        thread.join();
}
```

å½“å¤šä¸ªçº¿ç¨‹æ‰§è¡Œå‡½æ•° `f` çš„æ—¶å€™ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æˆåŠŸè°ƒç”¨ `lock()` ç»™äº’æ–¥é‡ä¸Šé”ï¼Œå…¶ä»–æ‰€æœ‰çš„çº¿ç¨‹ `lock()` çš„è°ƒç”¨å°†é˜»å¡žæ‰§è¡Œï¼Œç›´è‡³èŽ·å¾—é”ã€‚ç¬¬ä¸€ä¸ªè°ƒç”¨ `lock()` çš„çº¿ç¨‹å¾—ä»¥ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œæ‰§è¡Œæˆ‘ä»¬çš„ `std::cout` è¾“å‡ºè¯­å¥ï¼Œä¸ä¼šæœ‰ä»»ä½•å…¶ä»–çš„çº¿ç¨‹æ‰“æ–­è¿™ä¸ªæ“ä½œã€‚ç›´åˆ°çº¿ç¨‹æ‰§è¡Œ `unlock()`ï¼Œå°±è§£é”äº†äº’æ–¥é‡ã€‚é‚£ä¹ˆå…¶ä»–çº¿ç¨‹æ­¤æ—¶ä¹Ÿå°±èƒ½å†æœ‰ä¸€ä¸ªæˆåŠŸè°ƒç”¨ lockã€‚è‡³äºŽæ˜¯å“ªä¸ªçº¿ç¨‹æ‰ä¼šæˆåŠŸè°ƒç”¨ï¼Œè¿™ä¸ªæ˜¯ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šçš„

&gt; [!TIP] è¿™é‡Œæˆ‘ç†è§£çš„æ˜¯ï¼Œâ€œé”â€ æ˜¯ä¸€ç§å¹¿æ³›çš„æ¦‚å¿µï¼Œå¯ä»¥æœ‰å¤šç§å®žçŽ°æ–¹å¼ï¼Œc&#43;&#43; ä¸­çš„äº’æ–¥é‡ mutex å¯ä»¥ç”¨æ¥å®žçŽ°é”

### `std::lock_guard`

ä¸€èˆ¬æ¥è¯´ï¼Œä¸å»ºè®®ç›´æŽ¥ä½¿ç”¨äº’æ–¥é‡ mutex æ˜¾å¼åœ°è¿›è¡Œ `lock()` å’Œ `unlock()`ã€‚å¯ä»¥ç”¨ C&#43;&#43;11 æ ‡å‡†å¼•å…¥çš„ç®¡ç†ç±» `std::lock_guard`:

```cpp
void f() {
    std::lock_guard&lt;std::mutex&gt; lc{ m };  // ç­‰ä»·äºŽ m.lock()ï¼Œè¶…å‡ºä½œç”¨åŸŸè°ƒç”¨æžæž„æ¥ unlock
    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &#39;\n&#39;;
}
```

`std::lock_guard` å®žçŽ°æ¯”è¾ƒç®€å•ï¼Œå¯ä»¥çœ‹å®ƒåœ¨ [MSVC STL](https://github.com/microsoft/STL/blob/8dc4faadafb52e3e0a627e046b41258032d9bc6a/stl/inc/mutex#L448-L469) ä¸­çš„å®žçŽ°ã€‚

&gt; [!TIP] æˆ‘ä»¬è¦å°½å¯èƒ½çš„è®©äº’æ–¥é‡ä¸Šé”çš„**ç²’åº¦å°**ï¼Œåªç”¨æ¥ç¡®ä¿å¿…é¡»çš„å…±äº«èµ„æºçš„çº¿ç¨‹å®‰å…¨ã€‚
&gt; â€œç²’åº¦â€é€šå¸¸ç”¨äºŽæè¿°é”å®šçš„èŒƒå›´å¤§å°ï¼Œè¾ƒå°çš„ç²’åº¦æ„å‘³ç€é”å®šçš„èŒƒå›´æ›´å°ï¼Œå› æ­¤æœ‰æ›´å¥½çš„æ€§èƒ½å’Œæ›´å°‘çš„ç«žäº‰ã€‚

æ¯”å¦‚æœ‰çš„æ—¶å€™å¯ä»¥çœ‹åˆ°è¿™æ ·çš„å†™æ³•ï¼š

```cpp
void f() {
    //code..
    {
        std::lock_guard&lt;std::mutex&gt; lc{ m };
        // æ¶‰åŠå…±äº«èµ„æºçš„ä¿®æ”¹çš„ä»£ç ...
    }
    //code..
}
```

ä½¿ç”¨ `{}` åˆ›å»ºäº†ä¸€ä¸ªå—ä½œç”¨åŸŸï¼Œé™åˆ¶äº†å¯¹è±¡ `lc` çš„ç”Ÿå­˜æœŸï¼Œè¿›å…¥ä½œç”¨åŸŸæž„é€  `lock_guard` çš„æ—¶å€™ä¸Šé”ï¼ˆlockï¼‰ï¼Œç¦»å¼€ä½œç”¨åŸŸæžæž„çš„æ—¶å€™è§£é”ï¼ˆunlockï¼‰ã€‚

ä¸¾ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼š

```cpp
std::mutex m;

void add_to_list(int n, std::list&lt;int&gt;&amp; list) {
    std::vector&lt;int&gt; numbers(n &#43; 1);
    std::iota(numbers.begin(), numbers.end(), 0);  // iotaæ˜¯å¯¹vectorè¿›è¡Œé€’å¢žï¼ˆé»˜è®¤é€’å¢ž1ï¼‰èµ‹å€¼çš„æ–¹æ³•ï¼Œ0æ˜¯èµ·å§‹å€¼
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);  // 0æ˜¯èµ·å§‹å€¼

    {
        std::lock_guard&lt;std::mutex&gt; lc{ m };
        list.push_back(sum);
    }
}
void print_list(const std::list&lt;int&gt;&amp; list){
    std::lock_guard&lt;std::mutex&gt; lc{ m };
    for(const auto&amp; i : list){
        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
    }
    std::cout &lt;&lt; &#39;\n&#39;;
}

// ...... //

std::list&lt;int&gt; list;
std::thread t1{ add_to_list,i,std::ref(list) };  // ä¸Šé¢æåˆ°è¿‡ï¼Œä¼ å‚å³ä½¿æ˜¯å¼•ç”¨ï¼Œä¹Ÿä¼šè¢«å¤åˆ¶ï¼Œéœ€è¦ç”¨ std::ref
std::thread t2{ add_to_list,i,std::ref(list) };
std::thread t3{ print_list,std::cref(list) };  // const å¼•ç”¨éœ€è¦ç”¨ std::cref
std::thread t4{ print_list,std::cref(list) };
t1.join();
t2.join();
t3.join();
t4.join();
```

è¿™é‡Œçš„å…±äº«æ•°æ®åªæœ‰ `list`ï¼Œ å…ˆçœ‹ `add_to_list`ï¼Œåªæœ‰ `list.push_back(sum)` æ¶‰åŠåˆ°äº†å¯¹å…±äº«æ•°æ®çš„ä¿®æ”¹ï¼Œéœ€è¦è¿›è¡Œä¿æŠ¤ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ `{}` åŒ…è£¹ã€‚

å‡½æ•° `print_list()` æ‰“å° `list`ï¼Œç»™æ•´ä¸ªå‡½æ•°ä¸Šé”ï¼ŒåŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œã€‚æˆ‘ä»¬ä»£ç æ˜¯å¤šä¸ªçº¿ç¨‹æ‰§è¡Œè¿™ä¸¤ä¸ªå‡½æ•°ï¼Œä¸¤ä¸ªå‡½æ•°å…±äº«äº†ä¸€ä¸ªé”ï¼Œè¿™æ ·ç¡®ä¿äº†å½“æ‰§è¡Œå‡½æ•° `print_list()` æ‰“å°çš„æ—¶å€™ï¼Œ`list` çš„çŠ¶æ€æ˜¯ç¡®å®šçš„ã€‚æ‰“å°å‡½æ•° `print_list` å’Œ `add_to_list` å‡½æ•°çš„ä¿®æ”¹æ“ä½œåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œã€‚`print_list()` ä¸å¯èƒ½çœ‹åˆ°æ­£åœ¨è¢« `add_to_list()` ä¿®æ”¹çš„ `list`ã€‚

è‡³äºŽåˆ°åº•å“ªä¸ªå‡½æ•°å“ªä¸ªçº¿ç¨‹ä¼šå…ˆæ‰§è¡Œï¼Œæ‰§è¡Œå¤šå°‘æ¬¡ï¼Œè¿™äº›éƒ½ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šï¼Œä¹Ÿå®Œå…¨æœ‰å¯èƒ½è¿žç»­ 4 æ¬¡éƒ½æ˜¯æ‰§è¡Œå‡½æ•° `print_list` çš„çº¿ç¨‹æˆåŠŸè°ƒç”¨ `lock`ï¼Œä¼šæ‰“å°å‡ºäº†ä¸€æ ·çš„å€¼ï¼Œè¿™éƒ½å¾ˆæ­£å¸¸ã€‚

### `try_lock`

`try_lock` æ˜¯äº’æ–¥é‡ä¸­çš„ä¸€ç§å°è¯•ä¸Šé”çš„æ–¹å¼ã€‚ä¸Žå¸¸è§„çš„ `lock` ä¸åŒï¼Œ`try_lock` ä¼šå°è¯•ä¸Šé”ï¼Œä½†å¦‚æžœé”å·²ç»è¢«å…¶ä»–çº¿ç¨‹å ç”¨ï¼Œåˆ™ä¸ä¼šé˜»å¡žå½“å‰çº¿ç¨‹ï¼Œè€Œæ˜¯ç«‹å³è¿”å›žã€‚

å®ƒçš„è¿”å›žç±»åž‹æ˜¯ `bool` ï¼Œå¦‚æžœä¸Šé”æˆåŠŸå°±è¿”å›ž `true`ï¼Œå¤±è´¥å°±è¿”å›ž `false`ã€‚

è¿™ç§æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å¾ˆæœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦ä¿æŠ¤ä¸´ç•ŒåŒºçš„åŒæ—¶ï¼Œåˆä¸æƒ³çº¿ç¨‹å› ä¸ºç­‰å¾…é”è€Œé˜»å¡žçš„æƒ…å†µä¸‹ã€‚

```cpp
std::mutex mtx;

void thread_function(int id) {
    // å°è¯•åŠ é”
    if (mtx.try_lock()) {
        std::cout &lt;&lt; &#34;çº¿ç¨‹ï¼š&#34; &lt;&lt; id &lt;&lt; &#34; èŽ·å¾—é”&#34; &lt;&lt; std::endl;
        // ä¸´ç•ŒåŒºä»£ç 
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
        mtx.unlock(); // è§£é”
        std::cout &lt;&lt; &#34;çº¿ç¨‹ï¼š&#34; &lt;&lt; id &lt;&lt; &#34; é‡Šæ”¾é”&#34; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &#34;çº¿ç¨‹ï¼š&#34; &lt;&lt; id &lt;&lt; &#34; èŽ·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤&#34; &lt;&lt; std::endl;
    }
}
```
å¦‚æžœæœ‰ä¸¤ä¸ªçº¿ç¨‹è¿è¡Œè¿™æ®µä»£ç ï¼Œå¿…ç„¶æœ‰ä¸€ä¸ªçº¿ç¨‹æ— æ³•æˆåŠŸä¸Šé”ï¼Œè¦èµ° else çš„åˆ†æ”¯ã€‚

```cpp
std::thread t1(thread_function, 1);
std::thread t2(thread_function, 2);

t1.join();
t2.join();
```

å¯èƒ½çš„è¿è¡Œç»“æžœï¼š
```text
çº¿ç¨‹ï¼š1 èŽ·å¾—é”
çº¿ç¨‹ï¼š2 èŽ·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤
çº¿ç¨‹ï¼š1 é‡Šæ”¾é”
```

&gt; [!CAUTION]
&gt; åˆ‡å‹¿å°†å—ä¿æŠ¤æ•°æ®çš„æŒ‡é’ˆæˆ–å¼•ç”¨ä¼ é€’åˆ°äº’æ–¥é‡ä½œç”¨åŸŸä¹‹å¤–ï¼Œä¸ç„¶ä¿æŠ¤å°†å½¢åŒè™šè®¾ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“ä¾‹å­


```cpp
class Data {
    int a{};
    std::string b{};
public:
    void do_something() {
        // ä¿®æ”¹æ•°æ®æˆå‘˜ç­‰...
    }
};

class Data_wrapper {
    Data data;
    std::mutex m;
public:
    template&lt;class Func&gt;
    void process_data(Func func) {
        std::lock_guard&lt;std::mutex&gt; lc{m};
        func(data);  // å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å‡½æ•°
    }
};

Data* p = nullptr;

void malicious_function(Data&amp; protected_data) {
    p = &amp;protected_data; // å—ä¿æŠ¤çš„æ•°æ®è¢«ä¼ é€’åˆ°å¤–éƒ¨
}

Data_wrapper d;

void foo() {
    d.process_data(malicious_function);  // ä¼ é€’äº†ä¸€ä¸ªæ¶æ„çš„å‡½æ•°
    p-&gt;do_something();                   // åœ¨æ— ä¿æŠ¤çš„æƒ…å†µä¸‹è®¿é—®ä¿æŠ¤æ•°æ®
}
```

æˆå‘˜å‡½æ•°æ¨¡æ¿ `process_data` çœ‹èµ·æ¥ä¸€ç‚¹é—®é¢˜ä¹Ÿæ²¡æœ‰ï¼Œä½¿ç”¨ `std::lock_guard` å¯¹æ•°æ®åšäº†ä¿æŠ¤ï¼Œä½†æ˜¯è°ƒç”¨æ–¹ä¼ é€’äº† `malicious_function` è¿™æ ·ä¸€ä¸ªæ¶æ„çš„å‡½æ•°ï¼Œä½¿å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å¤–éƒ¨ï¼Œå¯ä»¥åœ¨æ²¡æœ‰è¢«äº’æ–¥é‡ä¿æŠ¤çš„æƒ…å†µä¸‹è°ƒç”¨ `do_something()`ã€‚

## æ­»é”ï¼šé—®é¢˜ä¸Žè§£å†³

_ä¸¤ä¸ªçº¿ç¨‹éœ€è¦å¯¹å®ƒä»¬æ‰€æœ‰çš„äº’æ–¥é‡åšä¸€äº›æ“ä½œï¼Œå…¶ä¸­æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªäº’æ–¥é‡ï¼Œä¸”ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹çš„äº’æ–¥é‡è§£é”ã€‚å› ä¸ºå®ƒä»¬éƒ½åœ¨ç­‰å¾…å¯¹æ–¹é‡Šæ”¾äº’æ–¥é‡ï¼Œæ²¡æœ‰çº¿ç¨‹å·¥ä½œã€‚ è¿™ç§æƒ…å†µå°±æ˜¯æ­»é”ã€‚==ä¸€èˆ¬åªæœ‰å¤šä¸ªäº’æ–¥é‡æ‰ä¼šé‡åˆ°æ­»é”é—®é¢˜==_

é¿å…æ­»é”çš„ä¸€èˆ¬å»ºè®®æ˜¯è®©ä¸¤ä¸ªäº’æ–¥é‡ä»¥ç›¸åŒçš„é¡ºåºä¸Šé”ï¼Œæ€»åœ¨äº’æ–¥é‡ B ä¹‹å‰é”ä½äº’æ–¥é‡ Aï¼Œå°±é€šå¸¸ä¸ä¼šæ­»é”ã€‚åé¢ç¤ºä¾‹ï¼š

```cpp
std::mutex m1,m2;
std::size_t n{};

void f() {
    std::lock_guard&lt;std::mutex&gt; lc1{ m1 };
    std::lock_guard&lt;std::mutex&gt; lc2{ m2 };
    &#43;&#43;n;
}
void f2() {
    std::lock_guard&lt;std::mutex&gt; lc1{ m2 };
    std::lock_guard&lt;std::mutex&gt; lc2{ m1 };
    &#43;&#43;n;
}
```

`f` ä¸Ž `f2` å› ä¸ºäº’æ–¥é‡ä¸Šé”é¡ºåºä¸åŒï¼Œå°±æœ‰æ­»é”é£Žé™©ã€‚å‡½æ•° `f` å…ˆé”å®š `m1`ï¼Œç„¶åŽå†å°è¯•é”å®š `m2`ï¼Œè€Œå‡½æ•° `f2` å…ˆé”å®š `m2` å†é”å®š `m1` ã€‚å¦‚æžœä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡Œï¼Œå®ƒä»¬å°±å¯èƒ½ï¼ˆå…·ä½“èŽ·å¾—é”çš„é¡ºåºç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šï¼Œä¸Šé¢é˜è¿°è¿‡ï¼‰ä¼šå½¼æ­¤ç­‰å¾…å¯¹æ–¹é‡Šæ”¾å…¶æ‰€éœ€çš„é”ï¼Œä»Žè€Œé€ æˆæ­»é”ã€‚

ä½†æœ‰æ—¶å€™å³ä½¿å›ºå®šäº†é”çš„é¡ºåºï¼Œä¾æ—§ä¼šäº§ç”Ÿé—®é¢˜ã€‚å½“æœ‰å¤šä¸ªäº’æ–¥é‡ä¿æŠ¤åŒä¸€ä¸ªç±»çš„å¯¹è±¡æ—¶ï¼Œå¯¹äºŽç›¸åŒç±»åž‹çš„ä¸¤ä¸ªä¸åŒå¯¹è±¡è¿›è¡Œæ•°æ®çš„äº¤æ¢æ“ä½œï¼Œä¸ºäº†ä¿è¯æ•°æ®äº¤æ¢çš„æ­£ç¡®æ€§ï¼Œå°±è¦é¿å…å…¶å®ƒçº¿ç¨‹ä¿®æ”¹ï¼Œç¡®ä¿æ¯ä¸ªå¯¹è±¡çš„äº’æ–¥é‡éƒ½é”ä½è‡ªå·±è¦ä¿æŠ¤çš„åŒºåŸŸã€‚å¦‚æžœæŒ‰ç…§å‰é¢çš„çš„é€‰æ‹©ä¸€ä¸ªå›ºå®šçš„é¡ºåºä¸Šé”è§£é”ï¼Œåˆ™æ¯«æ— æ„ä¹‰ï¼Œæ¯”å¦‚ï¼š

```cpp
struct X {
    X(const std::string&amp; str) :object{ str } {}

    friend void swap(X&amp; lhs, X&amp; rhs);
private:
    std::string object;
    std::mutex m;
};

void swap(X&amp; lhs, X&amp; rhs) {
    if (&amp;lhs == &amp;rhs) return;
    std::lock_guard&lt;std::mutex&gt; lock1{ lhs.m };
    std::lock_guard&lt;std::mutex&gt; lock2{ rhs.m };
    swap(lhs.object, rhs.object);
}
```

è€ƒè™‘ç”¨æˆ·è°ƒç”¨çš„æ—¶å€™å°†å‚æ•°äº¤æ¢ï¼Œå°±ä¼šäº§ç”Ÿæ­»é”ï¼š

```cpp
X a{ &#34;ðŸ¤£&#34; }, b{ &#34;ðŸ˜…&#34; };
std::thread t{ [&amp;] {swap(a, b); } };  // 1
std::thread t2{ [&amp;] {swap(b, a); } }; // 2
```

`1` æ‰§è¡Œçš„æ—¶å€™ï¼Œå…ˆä¸Šé” a çš„äº’æ–¥é‡ï¼Œå†ä¸Šé” b çš„äº’æ–¥é‡ã€‚

`2` æ‰§è¡Œçš„æ—¶å€™ï¼Œå…ˆä¸Šé” b çš„äº’æ–¥é‡ï¼Œå†ä¸Šé” a çš„äº’æ–¥é‡ã€‚

&gt; å®Œå…¨å¯èƒ½çº¿ç¨‹ A æ‰§è¡Œ 1 çš„æ—¶å€™ä¸Šé”äº† a çš„äº’æ–¥é‡ï¼Œçº¿ç¨‹ B æ‰§è¡Œ 2 ä¸Šé”äº† b çš„äº’æ–¥é‡ã€‚çº¿ç¨‹ A å¾€ä¸‹æ‰§è¡Œéœ€è¦ä¸Šé” b çš„äº’æ–¥é‡ï¼Œçº¿ç¨‹ B åˆ™è¦ä¸Šé” a çš„äº’æ–¥é‡æ‰§è¡Œå®Œæ¯•æ‰èƒ½è§£é”ï¼Œå“ªä¸ªéƒ½æ²¡åŠžæ³•å¾€ä¸‹æ‰§è¡Œï¼Œæ­»é”ã€‚

å¦‚ä½•è§£å†³ï¼Ÿå¯ä»¥ä½¿ç”¨ C&#43;&#43; æ ‡å‡†åº“ä¸­çš„ `std::lock`ï¼Œå®ƒèƒ½ä¸€æ¬¡æ€§é”ä½å¤šä¸ªäº’æ–¥é‡ï¼Œå¹¶ä¸”æ²¡æœ‰æ­»é”é£Žé™©ã€‚ä¿®æ”¹åŽ `swap` ä»£ç å¦‚ä¸‹ï¼š
```cpp
void swap(X&amp; lhs, X&amp; rhs) {
    if (&amp;lhs == &amp;rhs) return;
    std::lock(lhs.m, rhs.m);    // ç»™ä¸¤ä¸ªäº’æ–¥é‡ä¸Šé”
    std::lock_guard&lt;std::mutex&gt; lock1{ lhs.m,std::adopt_lock };
    std::lock_guard&lt;std::mutex&gt; lock2{ rhs.m,std::adopt_lock };
    swap(lhs.object, rhs.object);
}
```
å› ä¸ºå‰é¢å·²ç»ä½¿ç”¨äº† `std::lock` ä¸Šé”ï¼Œæ‰€ä»¥åŽé¢çš„ `std::lock_guard` æž„é€ éƒ½é¢å¤–ä¼ é€’äº†ä¸€ä¸ª `std::adopt_lock` å‚æ•°ï¼Œè®©å…¶é€‰æ‹©åˆ°ä¸ä¸Šé”çš„æž„é€ å‡½æ•°ã€‚å‡½æ•°é€€å‡ºä¹Ÿèƒ½æ­£å¸¸è§£é”ã€‚

`std::lock` ç»™ `lhs.m` æˆ– `rhs.m` ä¸Šé”æ—¶è‹¥æŠ›å‡ºå¼‚å¸¸ï¼Œåˆ™åœ¨é‡æŠ›å‰å¯¹ä»»ä½•å·²é”çš„å¯¹è±¡è°ƒç”¨ `unlock()` è§£é”ï¼Œä¹Ÿå°±æ˜¯ `std::lock` è¦ä¹ˆå°†äº’æ–¥é‡éƒ½ä¸Šé”ï¼Œè¦ä¹ˆä¸€ä¸ªéƒ½ä¸é”ã€‚

C&#43;&#43;17 æ–°å¢žäº† `std::scoped_lock` ï¼Œæä¾›æ­¤å‡½æ•°çš„ RAII åŒ…è£…ï¼Œé€šå¸¸å®ƒæ¯”è£¸è°ƒç”¨ `std::lock` æ›´å¥½ã€‚

æ‰€ä»¥æˆ‘ä»¬å‰é¢çš„ä»£ç å¯ä»¥æ”¹å†™ä¸ºï¼š
```cpp
void swap(X&amp; lhs, X&amp; rhs) {
    if (&amp;lhs == &amp;rhs) return;
    std::scoped_lock guard{ lhs.m,rhs.m };
    swap(lhs.object, rhs.object);
}
```

ä½¿ç”¨ `std::scoped_lock` å¯ä»¥å°†æ‰€æœ‰ `std::lock` æ›¿æ¢æŽ‰ï¼Œå‡å°‘é”™è¯¯å‘ç”Ÿã€‚ä¹Ÿå¯ä»¥ç”¨ `std::unique_lock`ï¼Œè¯¦æƒ…è§æ ‡å‡†åº“æ–‡æ¡£ã€‚

æ€»ç»“ï¼Œé¿å…æ­»é”è¦æ³¨æ„ï¼š

1. é¿å…åµŒå¥—é”ï¼šçº¿ç¨‹èŽ·å–ä¸€ä¸ªé”æ—¶ï¼Œå°±åˆ«å†èŽ·å–ç¬¬äºŒä¸ªé”ã€‚æ¯ä¸ªçº¿ç¨‹åªæŒæœ‰ä¸€ä¸ªé”ï¼Œè‡ªç„¶ä¸ä¼šäº§ç”Ÿæ­»é”ã€‚å¦‚æžœå¿…é¡»è¦èŽ·å–å¤šä¸ªé”ï¼Œä½¿ç”¨ `std::lock`ã€‚
2. é¿å…åœ¨æŒæœ‰é”æ—¶è°ƒç”¨å¤–éƒ¨ä»£ç 
3. ä½¿ç”¨å›ºå®šé¡ºåºèŽ·å–é”

## è¯»å†™é”

å¦‚æžœéœ€è¦å¤šçº¿ç¨‹è¯»å–å†™ï¼ˆå¤šçº¿ç¨‹è¯»ä¸å­˜åœ¨æ•°æ®ç«žäº‰ï¼›è€Œå†™å’Œè¯»å…±å­˜æ—¶å­˜åœ¨ç«žäº‰ï¼‰ï¼Œä½¿ç”¨ `std::mutex` å¼€é”€è¾ƒå¤§ã€‚è¿™æ—¶å¯ä»¥ç”¨ä¸“é—¨çš„è¯»å†™é”ï¼Œå³ `std::shared_timed_mutex` (C&#43;&#43;14)ï¼Œ`std::shared_mutex` (C&#43;&#43;17)ã€‚ç¤ºä¾‹ä»£ç ï¼š

```cpp
class Settings {
private:
    std::map&lt;std::string, std::string&gt; data_;
    mutable std::shared_mutex mutex_; // â€œM&amp;M è§„åˆ™â€ï¼šmutable ä¸Ž mutex ä¸€èµ·å‡ºçŽ°

public:
    void set(const std::string&amp; key, const std::string&amp; value) {
        std::lock_guard&lt;std::shared_mutex&gt; lock{ mutex_ };
        data_[key] = value;
    }

    std::string get(const std::string&amp; key) const {
        std::shared_lock&lt;std::shared_mutex&gt; lock(mutex_);
        auto it = data_.find(key);
        return (it != data_.end()) ? it-&gt;second : &#34;&#34;; // å¦‚æžœæ²¡æœ‰æ‰¾åˆ°é”®è¿”å›žç©ºå­—ç¬¦ä¸²
    }
};
```


---

> ä½œè€…:   
> URL: https://walker-ai.github.io/2025/acc27a1/  

