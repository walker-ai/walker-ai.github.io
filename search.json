[{"categories":null,"content":"基本概念 参考链接：https://zhuanlan.zhihu.com/p/1912965417447686461 缩放系数：$s=\\dfrac{\\text{max}(|\\text{min}_ {val}|, |\\text{max}_{val}|)}{2^{N-1}}$ 零点：$z=round(q_{min}-\\dfrac{r_{min}}{s})=round(-2^{N-1}-\\dfrac{r_{min}}{s})$ quantized: x_float = (x_int8 - zero_point) * scale dequantized: x_int8 = round(x_float/scale) + zero_point 这里有个前置知识就是，在神经网络中一般权重的形状 都是 $W\\in R^{O\\times I}$，其中 $O$ 表示输出通道(output channel), $I$ 表示输入通道(input channel)，对于矩阵乘法，即 $y = Wx$, $x\\in R^{I}, y\\in R^{O}$ ","date":"2025-08-07","objectID":"/2025/a793bc7/:1:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"量化粒度 - 三种形式 per-tensor 这是最粗粒度的量化方式。对整个 tensor 计算出一个统一的缩放因子（scale factor），然后将张量中的所有元素都使用这个缩放因子量化到低精度格式，例如 INT8。例如，一个 INT8 的 per-tensor 动态量化器会找到整个张量的最大绝对值，以此计算出一个缩放因子，然后将所有元素缩放到 INT8 的表示范围内 [-127, +127] 并进行取整1 。 per-token 这种量化方式的粒度比 per-tensor 更细。对于张量的每一个 token（通常指的是矩阵的每一行），都单独计算并应用一个缩放因子。 per-block 这种量化方式的粒度比 per-token 更细。它将张量在 token 维度上划分为若干个块（block）。对于每一个块内的所有 token（行），计算出一个统一的缩放因子并应用，。 per-channel 这种量化方式和 per-token 类似，但是量化维度不一样，对于张量的每一个通道（通常指 hidden dim 维度的一列），都单独计算并应用一个缩放因子。 ","date":"2025-08-07","objectID":"/2025/a793bc7/:2:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"离群值 (Outliers) 离群值的存在是模型量化时精度下降的主要原因。这是因为量化将模型中的连续数值映射到有限的离散数值范围（例如 INT4 的范围是 [-7, +7]）。如果数据中存在少数数值远超其他数据的离群值，为了表示这些极端的数值，量化的步长（resolution）就需要增大。 这样做的直接后果是： 大多数正常的、幅度较小的数值在量化后会变得非常接近甚至等于零。例如，如果一个数值比组内的最大值小很多倍，它可能会被量化为零，导致大量信息的丢失。 有限的量化比特无法精确表示这些大部分的正常数值，从而降低了整体的量化精度。 为了解决这个问题，需要采用平滑（smoothing）技术来减小激活或权重中离群值的影响，使得数值的幅度分布更加均匀。量化方法通过观察任务的 outliner 特点，来针对性地设计量化方法。 比较有代表性的是SmoothQuant ，它观察到在LLM的推理过程中，激活值（activations）中往往比权重值（weights）更容易出现显著的离群值。SmoothQuant 通过一种数学上等价的Per-channel缩放（channel-wise scaling）操作，将模型量化的难度从激活转移到权重。具体来说，它降低了激活中异常大的数值，使得激活值更容易被量化到低比特（例如 INT8），从而在保持模型精度的前提下，实现更高效的量化推理。 ","date":"2025-08-07","objectID":"/2025/a793bc7/:3:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"对称 / 非对称量化区别 项目 对称量化 非对称量化 是否有 zero point ❌ 固定为 0 ✅ 存在 zero_point 适用范围 权重量化（特别是 centered） 激活量化（值范围变化大） 运算简化 ✅ 快速，适合矩阵乘法 ❌ 多了减法，加快复杂度 表现力 ❌ 表达负偏移有限 ✅ 支持偏移，精度更高 效果稳定性 ✅ 稳定 ✅ 更灵活，适应动态变化 ","date":"2025-08-07","objectID":"/2025/a793bc7/:4:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"量化对象 - Linear (Dense) / Attention 参考链接：https://zhuanlan.zhihu.com/p/1895945361824122028 ","date":"2025-08-07","objectID":"/2025/a793bc7/:5:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"Linear 量化 指对模型的 Linear 层进行量化，Linear 层主要分布于： Attention 中的 Q/K/V/O projection MLP（FFN) 中的 gate/up/down Embedding ([vocab_size, hidden_size]) 和 LM Head ([hidden_size, vocab_size]) MoE 中的 expert ","date":"2025-08-07","objectID":"/2025/a793bc7/:5:1","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"Attention量化，以 SageAttention 为例 矩阵乘法中，对于每个矩阵你只能沿着公共维度进行量化（下图右边）。根据这个简单的原则，Attention 中四个矩阵可以量化的组合如下。注意能做 per-token，就能做 per-block 量化。其中 P 代表 $softmax(QK^T/\\sqrt{d})$ 这是因为在进行矩阵乘法 $QK^{T}$ 后，得到的结果矩阵的维度是 N × N（Q 和 K 的维度都是 N × d）。如果我们对 K 进行了per-channel 量化（下图左边，总共 d 个channel，每个 channel 包含 N 个元素），每个通道都有一个独立的scale factor，总共是 d 个 scale factor。在反量化（dequantization）时，我们需要将量化后的结果乘以对应的scale factor，而QK^T 的结果矩阵的维度是 NxN，根本没有 d 的通道维度不直接对应，因此无法使用 K 的通道维度的缩放因子进行正确的反量化。 Q K P V per-channel ❌ ❌ ❌ ✅ per-token ✅ ✅ ✅ ❌ per-block ✅ ✅ ✅ ❌ ","date":"2025-08-07","objectID":"/2025/a793bc7/:5:2","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"量化类型 - weight-only / weight-activation / KV cache INT 量化范式： FP32作为基准，提供了最大的数值范围和零精度损失，但存储开销最大。 如果用户不太关心效率，那么INT16格式是最佳选择。INT16格式是最精确的，如果是转换FP32，INT16甚至比FP16更精确。 对于对实时性要求高的服务，建议采用INT8量化方案，可以在保持较高精度的同时获得显著的性能提升。如果你的网络中某些层需要更高的精度，可以使用W8A16来解决这个问题。 在资源受限但对精度要求相对较低的场景，则可以采用INT4方案以获得最大的资源效益。 ","date":"2025-08-07","objectID":"/2025/a793bc7/:6:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"weight-only GPTQ $\\text{Frobenius}$ 范数，简称 F-范数，$||\\cdot||^{2}_{2}$ 表示对矩阵的 Frobenius 范数的平方（即所有元素平方和） Frobenius 范数可以用来衡量矩阵整体的大小，比如在误差分析中，可以用来评估两个矩阵之间的差异程度 GPTQ是一种训练后权重量化方法，使用基于二阶信息的逐层量化，成功将每个权重量化至 3-4 位，几乎没有精度损失。GPTQ 对某个 block 内的所有参数逐个量化，每个参数量化后，需要适当调整这个 block 内其他未量化的参数，以弥补量化造成的精度损失。 GPTQ 量化需要准备校准数据集。 OBS/OBQ/GPTQ等一系列工作的核心就是： 不直接最小化权重误差，而是：$\\min_{q(w)}||(q(w)-w)X||^2_{2}$ 给定权重矩阵W，有以下步骤： 收集激活样本（校准数据集） 计算输入协方差矩阵 $H = X^{T}X$ 逐列量化 W 的每一列 每列权重找最优 int4 表示 误差反馈，用 Hessian 更新下列的残差 保存量化结果，然后在推理阶段使用 int4 ✖️ float16 / int8的高效矩阵乘法 AWQ 参考：https://www.zhihu.com/search?type=content\u0026q=AWQ%20%E9%87%8F%E5%8C%96 AWQ观察到权重通道对性能的重要性各不相同，通过保留1%的显著权重可以大大减少量化误差。基于此观察，AWQ采用了激活感知权重量化来量化LLM，具体会专注于激活值较大的权重通道，并通过每通道缩放实现最佳量化效果。 误区：AWQ量化=W4A16量化 AWQ是一种对模型权重进行低比特量化的方法，使用该方法可以将模型权重(Weight)量化为4bit，并在计算激活值(Activation)时反量化为FP16，即W4A16。也可以基于AWQ方法将权重量化为3bit/8bit，并在计算时是使用4bit/8bit/16bit，由此衍生出W4A4、W4A8等一系列方法。 作者在原文中指出，W4A16可以在精度损失较小的情况下，大幅降低内存占用，且提升模型推理速度，是最常用的方法，因此AWQ和W4A16同镜率较高。 显著权重（权重并不同等重要，仅有部分显著权重对结果影响较大） 权重矩阵中显著权重位于哪个通道，找到这个通道，将这个通道内的部分保留原来的精度(fp16)，然后其他部分量化为低 bit。 步骤：在计算时，首先将激活值对每一列求绝对值的平均值，然后把平均值较大的一列对应的通道视作显著通道，保留FP16精度。对其他通道进行低比特量化，如下图： 这里详细解释一下“将激活值对每一列求绝对值的平均值，然后把平均值较大的一列对应的通道视作显著通道” 对于 $y=xW^{T}$，其中 $y\\in R^{B\\times O}, W\\in R^{O\\times I}, x\\in R^{B\\times I}$ （这里 chatgpt 的解释是，在数学上 $y = Wx$，实现中记为 $y=xW^{T}$） 这张图中的 $X\\in R^{I\\times B}, W\\in R^{O\\times I}$，因此 $y=Wx \\in R^{O\\times B}$ 所以不管数学上的表达还是实际上的代码实现，y 的输出通道始终由权重的输出通道决定，即 y 的输出通道是否是显著值，就看对应的激活值那一列，所以这里是求的每一列的绝对值的平均值，把平均值较大的一列视为显著通道。 但是如果这样做，权重矩阵中有的元素需要用 FP16，而其他元素需要用 INT8，不好写 kernel。因此就引入了 Scaling 方法 Scaling（量化时对显著权重进行放大可以降低量化误差） 量化误差主要来源于对权重的量化，AWQ的目标是通过缩放显著权重，减少量化误差 核心思想：对显著权重按比例放大，然后在计算时相应地缩小输入，这样在量化过程中显著权重的相对误差被降低。 量化函数（这里量化函数不是表示量化后的整数值，而是指 反量化之后的近似权重值，是直接给出最终用于推理的值）： 其中 $N$ 是量化后的比特数，$\\Delta$ 是量化因子(scaler)，$\\Delta= \\dfrac{max(|w|)}{2^{N-1}}$ $w’=Round(\\frac{w}{\\Delta})$ 是量化过程， $\\Delta\\cdot w’$ 是反量化过程 $w, \\Delta, x$ 都是 fp16 格式，不会带来精度损失，精度损失全部来源于 round 函数 对于权重 $\\text{w}$ 中的单个元素 $w$，引入一个缩放因子 $s\u003e1$，量化过程将 $w$ 与该因子相乘，写作：$\\text{w}’=Round(\\dfrac{ws}{\\Delta’})$，相应将反量化过程写作 $\\dfrac{\\Delta’ \\cdot w’}{s}$，对 x 进行逆缩放，则： 其原始量化误差为： RoundErr：四舍五入误差，为±0.5 $\\Delta$：量化比例因子，决定误差绝对值大小 缩放后的量化误差： 所以误差比值可以描述为 $\\dfrac{\\Delta’}{\\Delta}\\cdot \\dfrac{1}{s}$，我们认为 $\\Delta’\\approx \\Delta$，加上 $s\u003e1$，所以作者认为量化时对显著权重进行放大，可以降低量化误差 从量化函数来看，AWQ 属于对称量化。这里量化因子 q_scale: $\\Delta’ = \\dfrac{max(|w|)}{2^{N-1}}$ 自动计算缩放系数 按照上文的分析，我们需要找到权重矩阵每个通道的缩放系数，使得量化误差最小，即最小化公式4： 按照作者的观点，激活值越大，对应通道越显著，就应该分配更大的缩放系数降低其量化误差。这里为了简单记忆，作者统计了各通道的平均激活值（计算输入矩阵各列绝对值的平均值），并直接将此作为各通道的缩放系数。 SmoothQuant 是一个 W8A8 算法，本质还是跟 AWQ 有点像，主要是将 激活量化 的难度转移到权重上，简单来说就是 除以一个值，然后权重乘以一个值： $$ Y=(X*\\text{diag}(s)^{-1})*(\\text{diag}(s)*W) $$ 也就是对activate (也就是X)进行缩放，并把相反的缩放系数应用到对应的weight(也就是W)上，得到数学上等价的结果。它的核心观察在于： 由于activation outlier的存在，activation的分布非常不规则； weight分布均匀 这样，通过上面的操作，试图把 activation 变得更均匀，而把 weightde 均匀分布变得没有那么均匀，也就是把activation 量化de 难度部分平摊到weight 上 并且该论文主要实现了三种量化方法：per-tensor、per-token、per-channel。同时也进行了static 和 dynamic量化的区分： static：离线使用标定数据计算好缩放系数 dynamic：在线运行的时候统计缩放系数 ","date":"2025-08-07","objectID":"/2025/a793bc7/:6:1","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"weight-activation LLM.int8() 发现激活中的异常值集中在一小部分通道中。基于这一点，LLM.int8() 根据输入通道内的离群值分布将激活和权重分成两个不同的部分。包含激活值和权重的异常数据的通道以FP16格式存储，其他通道则以INT8格式存储。 ","date":"2025-08-07","objectID":"/2025/a793bc7/:6:2","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"支撑量化的一些算子和库 ","date":"2025-08-07","objectID":"/2025/a793bc7/:7:0","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":null,"content":"Marlin 支持混合精度运算，例如 FP16 * INT4 运算，FP8 * INT4运算 一种支持 W4A16的 GEMM kernel（一定程度上kernel 实现和量化算法是独立的），因此 marlin kernel 也支持 AWQ 量化模型执行。原始的Marlin Kernel只支持W4A16计算模式，而 QQQ 在 Marlin kernel 的基础上，支持了 W4A8 的计算模式。 ","date":"2025-08-07","objectID":"/2025/a793bc7/:7:1","tags":null,"title":"量化","uri":"/2025/a793bc7/"},{"categories":["找工作"],"content":"记录一些常用的 CUDA 算子写法 ","date":"2025-08-07","objectID":"/2025/ebaa040/:0:0","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Reduce ","date":"2025-08-07","objectID":"/2025/ebaa040/:1:0","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Reduce Sum template \u003cconst int kWarpSize = 256\u003e __device__ __forceinline__ float warp_reduce_sum_f32(float val) { #pragma unroll for (int mask = kWarpSize; mask \u003e= 1; mask \u003e\u003e= 1) { val += __shfl_xor_sync(0xffffffff, val, mask); } return val; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:1:1","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Block reduce sum template \u003cconst int NUM_THREADS = 256\u003e __device__ float block_reduce_sum_f32(float val) { int tid = threadIdx.x; int idx = blockIdx.x * blockDim.x + tid; constexpr int NUM_WARPS = (NUM_THREADS + WARP_SIZE - 1) / WARP_SIZE; static __shared__ reduce_sum[NUM_WARPS]; float sum = warp_reduce_sum_f32\u003cWARP_SIZE\u003e(val); if (lane == 0) reduce_sum[warp] = sum; __syncthreads(); sum = (lane \u003c NUM_WARPS) ? reduce_sum[lane] : 0.0f; sum = warp_reduce_sum_f32\u003cNUM_WARPS\u003e(sum); sum = __shfl_sync(0xffffffff, sum, 0, 32); return sum; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:1:2","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Reduce Max template \u003cconst int kWarpSize = 256\u003e __device__ __forceinline__ float warp_reduce_max_f32(float val) { #pragma unroll for (int mask = kWarpSize; mask \u003e= 1; mask \u003e\u003e= 1) { val = fmaxf(val, __shfl_xor_sync(0xffffffff, val, mask)); } return val; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:1:3","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"block reduce max // grid 1D block 1D, grid(N/256), block(256) template \u003cconst int NUM_THREADS = 256\u003e __device__ float block_reduce_max_f32(float val) { constexpr int NUM_WARPS = (NUM_THREADS + WARP_SIZE - 1) / WARP_SIZE; int warp = threadIdx.x / WARP_SIZE; int lane = threadIdx.x % WARP_SIZE; static __shared__ float reduce_max[NUM_WARPS]; float value = warp_reduce_sum_f32\u003cWARP_SIZE\u003e(val); if (lane == 0) { shared[warp] = value; } __syncthreads(); value = (lane \u003c NUM_WARPS) ? shared[lane] : -FLT_MAX; value = warp_reduce_max_f32\u003cNUM_WARPS\u003e(value); value = __shfl_sync(0xffffffff, value, 0, 32); return value; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:1:4","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Softmax ","date":"2025-08-07","objectID":"/2025/ebaa040/:2:0","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"naive版 template \u003cconst int NUM_THREADS = 256\u003e __global__ void softmax_f32_per_token_kernel(float *x, float *y, int N) { const int tid = threadIdx.x; const int idx = blockIdx.x * blockDim.x + tid; float exp_val = (idx \u003c N) ? expf[x[idx]] : 0.0f; float exp_sum = block_reduce_sum_f32\u003cNUM_THREADS\u003e(exp_val); if (idx \u003c N) { y[idx] = exp_val / exp_sum; } } ","date":"2025-08-07","objectID":"/2025/ebaa040/:2:1","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"向量化存取 #define FLOAT4(value) (reinterpret_cast\u003cint4 *\u003e(\u0026(value))[0]) template \u003cconst int NUM_THREADS = 256\u003e __global__ void softmax_f32x4_per_token_kernel(float *x, float *y, int N) { const int tid = threadIdx.x; const int idx = (blockIdx.x * blockDim.x + tid) * 4; // 向量化 取 float4 reg_x = FLOAT4(x[idx]); float4 reg_exp; reg_exp.x = (idx + 0 \u003c N) ? expf(reg_x.x) : 0.0f; reg_exp.y = (idx + 1 \u003c N) ? expf(reg_x.y) : 0.0f; reg_exp.z = (idx + 2 \u003c N) ? expf(reg_x.z) : 0.0f; reg_exp.w = (idx + 3 \u003c N) ? expf(reg_x.w) : 0.0f; float exp_val = (reg_exp.x + reg_exp.y + reg_exp.z + reg_exp.w); float exp_sum = block_reduce_sum_f32\u003cNUM_THREADS\u003e(exp_val); // 向量化 存 if (idx + 3 \u003c N) { float4 reg_y; reg_y.x = reg_exp.x / exp_sum; reg_y.y = reg_exp.y / exp_sum; reg_y.z = reg_exp.z / exp_sum; reg_y.w = reg_exp.w / exp_sum; FLOAT4[y[idx]] = reg_y; } } ","date":"2025-08-07","objectID":"/2025/ebaa040/:2:2","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"safe-softmax template \u003cconst int NUM_THREADS = 256\u003e __global__ void safe_softmax_f32_per_token_kernel(float *x, float *y, int N) { const int tid = threadIdx.x; const int idx = blockIdx.x * blockDim.x + tid; float val = (idx \u003c N) ? x[idx] : -FLT_MAX; float max_val = block_reduce_max_f32\u003cNUM_THREADS\u003e(val); float exp_val = (idx \u003c N) ? expf[x[idx] - max_val] : 0.0f; float exp_sum = block_reduce_sum_f32\u003cNUM_THREADS\u003e(exp_val); if (idx \u003c N) y[idx] = exp_val / exp_sum; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:2:3","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"online-softmax struct __align__(8) MD { float M; float D; }; template \u003cconst int NUM_THREADS = 256\u003e __global__ void online_softmax_f32_per_token_kernel(float *x, float *y, int N) { // } __global__ void sgemm_naive_f32_kernel(float *a, float *b, float *c, int M, int N, int K) { int n = blockIdx.x * blockDim.x + threadIdx.x; int m = blockIdx.y * blockDim.y + threadIdx.y; if (m \u003c M \u0026\u0026 n \u003c N) { float psum = 0.0f; #pragma unroll for (int k = 0; k \u003c K; ++ k) { psum += a[m * K + k] * [k * N + n]; } c[m * M + n] = psum; } } template \u003cconst int BM = 32, const int BN = 32, const int BK = 32\u003e __global__ void sgemm_sliced_k_f32_kernel(float *a, float *b, float *c, int M, int N, int K) { // block tile ： 32x32 的 block 处理 c 上一块 32x32 的元素计算 // K tile： 使用共享内存，将 K 分块成 BK 大小的块 __shared__ float s_a[BM][BK], s_b[BK][BN]; int bx = blockIdx.x; int by = blockIdx.y; int tx = threadIdx.x; int ty = threadIdx.y; int tid = threadIdx.y * blockDim.x + tx; int load_smem_a_m = tid / 32; int load_smem_a_n = tid % 32; int load_smem_b_n = tid / 32; int load_smem_b_k = tid % 32; int load_gmem_a_m = by * BM + load_smem_a_m; // global row of a and c int load_gmem_b_n = bx * BN + load_smem_b_n; // global col of b and c if (load_gmem_a_m \u003e= M || load_gmem_b_n \u003e= N) return; float sum = 0.0f; for (int bk = 0; bk \u003c (K + BK - 1) / BK; ++ bk) { // 加载 a 的全局内容到共享内存 int load_gmem_a_k = bk * BK + load_smem_a_k; int load_gmem_a_addr = load_gmem_a_m * K + load_gmem_a_k; s_a[load_gmem_a_m][load_gmem_a_k] = a[load_gmem_a_addr]; // 加载 b 的全局内容到共享内存 int load_gmem_b_k = bk * BK + load_smem_b_k; int load_gmem_b_addr = load_gmem_b_k * N + load_gmem_b_n; s_b[load_gmem_b_k][load_gmem_b_n] = b[load_gmem_b_addr]; __syncthreads(); } #pragma unroll for (int k = 0; k \u003c BK; ++ k) { // 共享内存内进行 block gemm sum += s_a[load_smem_a_m][k] * s_b[k][load_smem_b_n]; } __syncthreads(); // 存 int store_gmem_c_addr = load_gmem_a_m * N + load_gmem_b_n; c[store_gmem_c_addr] = sum; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:2:4","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Matmul ","date":"2025-08-07","objectID":"/2025/ebaa040/:3:0","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"naive 版 __global__ void sgemm_naive_f32_kernel(float *a, float *b, float *c, int M, int N, int K) { int n = blockIdx.x * blockDim.x + threadIdx.x; int m = blockIdx.y * blockDim.y + threadIdx.y; if (m \u003c M \u0026\u0026 n \u003c N) { float psum = 0.0f; #pragma unroll for (int k = 0; k \u003c K; ++ k) { psum += a[m * K + k] * [k * N + n]; } c[m * M + n] = psum; } } ","date":"2025-08-07","objectID":"/2025/ebaa040/:3:1","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"shared_mem 优化 template \u003cconst int BM = 32, const int BN = 32, const int BK = 32\u003e __global__ void sgemm_sliced_k_f32_kernel(float *a, float *b, float *c, int M, int N, int K) { // block tile ： 32x32 的 block 处理 c 上一块 32x32 的元素计算 // K tile： 使用共享内存，将 K 分块成 BK 大小的块 __shared__ float s_a[BM][BK], s_b[BK][BN]; int bx = blockIdx.x; int by = blockIdx.y; int tx = threadIdx.x; int ty = threadIdx.y; int tid = threadIdx.y * blockDim.x + tx; int load_smem_a_m = tid / 32; int load_smem_a_n = tid % 32; int load_smem_b_n = tid / 32; int load_smem_b_k = tid % 32; int load_gmem_a_m = by * BM + load_smem_a_m; // global row of a and c int load_gmem_b_n = bx * BN + load_smem_b_n; // global col of b and c if (load_gmem_a_m \u003e= M || load_gmem_b_n \u003e= N) return; float sum = 0.0f; for (int bk = 0; bk \u003c (K + BK - 1) / BK; ++ bk) { // 加载 a 的全局内容到共享内存 int load_gmem_a_k = bk * BK + load_smem_a_k; int load_gmem_a_addr = load_gmem_a_m * K + load_gmem_a_k; s_a[load_gmem_a_m][load_gmem_a_k] = a[load_gmem_a_addr]; // 加载 b 的全局内容到共享内存 int load_gmem_b_k = bk * BK + load_smem_b_k; int load_gmem_b_addr = load_gmem_b_k * N + load_gmem_b_n; s_b[load_gmem_b_k][load_gmem_b_n] = b[load_gmem_b_addr]; __syncthreads(); } #pragma unroll for (int k = 0; k \u003c BK; ++ k) { // 共享内存内进行 block gemm sum += s_a[load_smem_a_m][k] * s_b[k][load_smem_b_n]; } __syncthreads(); // 存 int store_gmem_c_addr = load_gmem_a_m * N + load_gmem_b_n; c[store_gmem_c_addr] = sum; } ","date":"2025-08-07","objectID":"/2025/ebaa040/:3:2","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"Transpose ","date":"2025-08-07","objectID":"/2025/ebaa040/:4:0","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"naive __global__ void transpose_naive(float *input, float *output, int M, int N) { int n = blockIdx.x * blockDim.x + threadIdx.x; int m = blockIdx.y * blockDim.y + threadIdx.y; if (m \u003c M \u0026\u0026 n \u003c N) { output[n * M + m] = input[m * N + n]; } } ","date":"2025-08-07","objectID":"/2025/ebaa040/:4:1","tags":["八股"],"title":"CUDA 常用算子案例","uri":"/2025/ebaa040/"},{"categories":["找工作"],"content":"计算机网络基础复习 ","date":"2025-08-06","objectID":"/2025/3dc98a3/:0:0","tags":["八股"],"title":"计算机网络","uri":"/2025/3dc98a3/"},{"categories":["找工作"],"content":"TCP 协议与 UDP 协议 ","date":"2025-08-06","objectID":"/2025/3dc98a3/:1:0","tags":["八股"],"title":"计算机网络","uri":"/2025/3dc98a3/"},{"categories":["找工作"],"content":"三次握手 为什么三次握手可以建立\"可靠\"传输？ 第一次握手：如果成功，Server 则确认 Client的发送信道可靠，Server 也确认 自己的接收信道可靠。 第二次握手：如果成功，Client 则确认 Server的发送信道和接收信道都可靠，Client 也确认 自己的发送信道和接收信道都可靠。 第三次握手：如果成功，Server 则确认 Client的接收信道可靠，Server 也确认 自己的发送信道可靠。 此时，Server和Client双方都确认 自己和对方的发送和接收通道已经可以正常运行。 为什么不进行两次握手？ Server 无法确认 Client 的接收信道和自己的发送信道 是否可靠。即 Server 无法知道客户端是否收到了 SYN-ACK 响应 为什么不需要超过三次握手？ 四次或更多次握手将带来不必要的开销，且不会带来额外的可靠性优势，三次足以。 ","date":"2025-08-06","objectID":"/2025/3dc98a3/:1:1","tags":["八股"],"title":"计算机网络","uri":"/2025/3dc98a3/"},{"categories":["找工作"],"content":"四次挥手 为什么需要四次挥手？ 服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序： 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数 什么时候变成三次挥手？ 当被动关闭方（上图的服务端）在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。 ","date":"2025-08-06","objectID":"/2025/3dc98a3/:1:2","tags":["八股"],"title":"计算机网络","uri":"/2025/3dc98a3/"},{"categories":["找工作"],"content":"可靠传输 TCP 是通过序列号、确认应答、校验和、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。 重传机制 常见的重传机制 超时重传 快速重传 SACK D-SACK 数据包在传输过程中丢失，这时就需要使用重传机制。 流量控制 TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收 发送窗口图示，可以分为四个部分： 已经发送并且确认的 TCP 段（已经发送并确认） 已经发送但是没有确认的 TCP 段（已经发送未确认） 未发送但是接收方准备接收的 TCP 段（可以发送） 未发送并且接收方也并未准备接受的 TCP 段（不可发送） 接收窗口图示，可以分为三个部分： 已经接收并且已经确认的 TCP 段（已经接收并确认） 等待接收且允许发送方发送 TCP 段（可以接收未确认） 不可接收且不允许发送方发送 TCP 段（不可接收） 拥塞控制 拥塞控制就是为了防止过多的数据注入到网络中， 为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。 TCP 的拥塞控制采用了四种算法，即 慢开始、 拥塞避免、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。 慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。 拥塞避免： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1. 快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 ","date":"2025-08-06","objectID":"/2025/3dc98a3/:1:3","tags":["八股"],"title":"计算机网络","uri":"/2025/3dc98a3/"},{"categories":["找工作"],"content":"《HOT100》做题记录 ","date":"2025-03-26","objectID":"/2025/a4da344/:0:0","tags":null,"title":"《HOT100》","uri":"/2025/a4da344/"},{"categories":["找工作"],"content":"5.最长回文子串 🔗 给你一个字符串 s，找到 s 中最长的 回文 子串。 class Solution { static const int N = 1e3 + 10; static const int p[N], b[N]; public: string longestPalindrome(string s) { // 用 manacher 算法求解 int k = 0, n = 0; auto init = [\u0026]() { b[k ++ ] = '$', b[k ++ ] = '#'; for (auto c : s) { b[k ++ ] = c; b[k ++ ] = '#'; } b[k ++ ] = '^'; n = k; }; init(); auto manacher = [$]() { int mr = 0, mid = 0; for (int i = 1; i \u003c n; i ++ ) { if (i \u003c mr) p[i] = max(2 * mid - i, mr - i); else p[i] = 1; while (b[i - p[i]] == b[i + p[i]]) p[i] ++ ; if (i + p[i] \u003e mr) { mr = i + p[i]; mid = i; } } }; manacher(); // 如果只是求最长回文子串的长度，返回res即可 int res = 0, max_i = 0; for (int i = 0; i \u003c n; i ++ ) { if (p[i] \u003e res) { res = p[i]; max_i = i; } } // 如果是求具体的回文子串，需要根据最长长度截取 int start = max_i - (res - 1); int end = max_i + (res - 1); for (int i = start; i \u003c= end; i ++ ) { if (i == 0 || i == n - 1) continue; if (i % 2 == 0) ans.push_back(b[i]); } return ans; } }; ","date":"2025-03-26","objectID":"/2025/a4da344/:0:1","tags":null,"title":"《HOT100》","uri":"/2025/a4da344/"},{"categories":["找工作"],"content":"《面试经典150题》做题记录，原题单链接 ","date":"2025-03-24","objectID":"/2025/be012dd/:0:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"数组/字符串 ","date":"2025-03-24","objectID":"/2025/be012dd/:1:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"88.合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 腾讯PCG-青云 一、二面手撕 class Solution { public: void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { int p1 = m - 1, p2 = n - 1, p = m + n - 1; while (p2 \u003e= 0) { if (p1 \u003e= 0 \u0026\u0026 nums1[p1] \u003e nums2[p2]) { nums1[p -- ] = nums1[p1 -- ]; } else { nums1[p -- ] = nums2[p2 -- ]; } } } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"27.移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作： 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。 返回 k。 // 用栈存储去除后的元素 class Solution { public: int removeElement(vector\u003cint\u003e\u0026 nums, int val) { int top = 0; for (int x : nums) { if (x != val) { nums[top ++ ] = x; } } return top; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"26.删除有序数组中的重复项 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 class Solution { public: int removeDuplicates(vector\u003cint\u003e\u0026 nums) { int siz = nums.size(); int top = 0; for (int i = 0; i \u003c siz; i ++ ) { int x = nums[i]; if (i \u0026\u0026 x == nums[i - 1]) continue; // 跳过重复数字 nums[top ++ ] = x; } return top; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:3","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"80.删除有序数组中的重复项 II 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。 // 用栈模拟, top表示栈顶, 栈存储全部不重复元素 class Solution { public: int removeDuplicates(vector\u003cint\u003e\u0026 nums) { int top = 2; int siz = nums.size(); for (int i = 2; i \u003c siz; i ++ ) { if (nums[i] != nums[top - 2]) nums[top ++ ] = nums[i]; } return min(top, siz); } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:4","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"169.多数元素 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 `⌊ n/2 ⌋`` 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 // 摩尔投票法 class Solution { public: int majorityElement(vector\u003cint\u003e\u0026 nums) { int x = 0, votes = 0; for (int num: nums) { if (votes == 0) x = num; votes += num == x ? 1 : -1; } return x; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:5","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"189.轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] class Solution { public: void rotate(vector\u003cint\u003e\u0026 nums, int k) { // 根据 k 计算出每个元素轮转后的位置，然后填入新的 vector 中 int n = nums.size(); k %= n; std::reverse(nums.begin(), nums.end()); std::reverse(nums.begin(), nums.begin() + k); std::reverse(nums.begin() + k, nums.end()); } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:6","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"121.买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 状态机模型 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { // 买入-\u003e卖出，求区间端点差值的最大值 int ans = 0; int min_price = prices[0]; for (int p : prices) { ans = max(ans, p - min_price); min_price = min(min_price, p); } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:7","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"122.买卖股票的最佳时机II 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 状态划分参考 class Solution { public: int maxProfit(vector\u003cint\u003e\u0026 prices) { // 状态机模型 // f[i][j]表示所有考虑前 i 个步骤，且第 i 个状态是 j(0未持股, 1持股)的集合，属性是最大值 // 对于f[i][j] // 如果i-1步是0，0-\u003e0（未持股且不买入）；0-\u003e1（未持股且买入）； // 如果i-1步是1，1-\u003e0（持股且卖出）；1-\u003e1（持股且不卖出） int n = prices.size(); int INF = 0x3f3f3f3f; vector\u003cvector\u003cint\u003e\u003e f(n + 1, vector\u003cint\u003e(2, 0)); // f[n][2] prices.insert(prices.begin(), 0); f[0][0] = 0, f[0][1] = -INF; for (int i = 1; i \u003c= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1] + prices[i]); f[i][1] = max(f[i - 1][1], f[i - 1][0] - prices[i]); } return max(f[n][0], f[n][1]); } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:8","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"55.跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 class Solution { public: bool canJump(vector\u003cint\u003e\u0026 nums) { // 只要跳到了不为 0 的格子上，就一直可以往后跳 // 转为合并区间问题 int mx = 0; for (int i = 0; i \u003c nums.size(); i ++ ) { if (i \u003e mx) return false; mx = max(mx, i + nums[i]); } return true; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:9","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"45.跳跃游戏II 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 \u003c= j \u003c= nums[i] i + j \u003c n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 class Solution { public: int jump(vector\u003cint\u003e\u0026 nums) { int ans = 0; int cur_right = 0; // 已建造的桥的右端点 int next_right = 0; // 下一座桥的右端点的最大值 for (int i = 0; i + 1 \u003c nums.size(); i ++ ) { // 遍历的过程中，记录下一座桥的最远点 next_right = max(next_right, i + nums[i]); if (i == cur_right) { // 无路可走，必须建桥 cur_right = next_right; // 建桥后，最远可以到达 next_right ans ++ ; } } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:10","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"274.H指数 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。 即：给你一个数组，求一个最大的 $h$，使得数组中有至少 $h$ 个数都大于等于 $h$。 class Solution { public: int hIndex(vector\u003cint\u003e\u0026 citations) { int n = citations.size(); auto check = [\u0026](int mid) -\u003e bool { int n = citations.size(); int res = 0; for (int i = 0; i \u003c n; i ++ ) { if (citations[i] \u003c mid) res ++ ; } return (n - res) \u003e= mid; }; int l = -1, r = n + 1; while (l + 1 \u003c r) { int mid = l + (r - l) / 2; if (check(mid)) l = mid; else r = mid; } return l; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:11","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"380. O(1) 时间插入、删除和获取随机元素 实现RandomizedSet 类： RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。 // 哈希表 + 变长数组 class RandomizedSet { public: RandomizedSet() { srand((unsigned)time(NULL)); } bool insert(int val) { if (indices.count(val)) { return false; } int index = nums.size(); nums.emplace_back(val); indices[val] = index; return true; } // 主要是这里，删除默认让尾部的值覆盖要删除的元素，然后erase掉指定的值 bool remove(int val) { if (!indices.count(val)) return false; int index = indices[val]; int last = nums.back(); nums[index] = last; indices[last] = index; nums.pop_back(); indices.erase(val); return true; } int getRandom() { int randomIndex = rand() % nums.size(); return nums[randomIndex]; } private: vector\u003cint\u003e nums; unordered_map\u003cint, int\u003e indices; }; /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-\u003einsert(val); * bool param_2 = obj-\u003eremove(val); * int param_3 = obj-\u003egetRandom(); */ ","date":"2025-03-24","objectID":"/2025/be012dd/:1:12","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"238.除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在 32位 整数范围内。请不要使用除法，且在 O(n) 时间复杂度内完成此题。 class Solution { public: vector\u003cint\u003e productExceptSelf(vector\u003cint\u003e\u0026 nums) { // 用“前缀数组”和“后缀数组”完成 int n = nums.size(); vector\u003cint\u003e pre(n + 1, 1); vector\u003cint\u003e suf(n + 1, 1); vector\u003cint\u003e ans(n); for (int i = 1; i \u003c= n; i ++ ) { pre[i] = pre[i - 1] * nums[i - 1]; } for (int i = n - 1; i \u003e= 1; i -- ) { suf[i] = suf[i + 1] * nums[i]; } for (int i = 0; i \u003c n; i ++ ) { ans[i] = pre[i] * suf[i + 1]; } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:13","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"134.加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 本题是特殊做法，通用做法是单调队列，详情见：AcWing.1088 class Solution { public: int canCompleteCircuit(vector\u003cint\u003e\u0026 gas, vector\u003cint\u003e\u0026 cost) { int n = gas.size(); for (int i = 0, j = 0; i \u003c n;) { // 枚举起点 int left = 0; for (j = 0; j \u003c n; j ++ ) { // 枚举走了几步 int k = (i + j) % n; left += gas[k] - cost[k]; if (left \u003c 0) break; // 如果剩余油量不够，则退出枚举，这里有个贪心思想，i~j 之间不用枚举 } if (j == n) return i; i = i + j + 1; } return -1; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:14","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"135.分发糖果 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子中，评分更高的那个会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 class Solution { public: int candy(vector\u003cint\u003e\u0026 ratings) { int n = ratings.size(); int ans = n; // 每个孩子至少1个糖果 for (int i = 0; i \u003c n; i ++ ) { // 找起始点，满足递增才可以作为起始点 int start = i \u003e 0 \u0026\u0026 ratings[i - 1] \u003c ratings[i] ? i - 1 : i; // 找严格递增段 while (i + 1 \u003c n \u0026\u0026 ratings[i] \u003c ratings[i + 1]) { i ++ ; } // 循环结束时，i 为峰顶 int top = i; // 找严格递减段 while (i + 1 \u003c n \u0026\u0026 ratings[i] \u003e ratings[i + 1]) { i ++ ; } // 循环结束时，i 为谷底 int inc = top - start; // start 到 top 严格递增 int dec = i - top; // top 到 i 严格递减 ans += (inc * (inc - 1) + dec * (dec - 1)) / 2 + max(inc, dec); // 等差数列公式，由于求最少糖果数，所以公差为1 } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:15","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"42.接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 class Solution { public: int trap(vector\u003cint\u003e\u0026 height) { int n = height.size(), pre_max = 0, suf_max = 0; // pre_max之前最高的柱子高度，suf_max之后最高的柱子高度 // 注意到下标 i 处能接的雨水量由 pre_max[i] 和 suf_max[i] 中的最小值决定。 int left = 0, right = n - 1, res = 0; while (left \u003c right) { pre_max = max(pre_max, height[left]); // 维护pre_max suf_max = max(suf_max, height[right]); // 维护suf_max if (pre_max \u003c suf_max) { res += pre_max - height[left]; left ++ ; } else { res += suf_max - height[right]; right -- ; } } return res; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:16","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"13.罗马数字转整数 给你一个罗马数字，将其转换为整数 unordered_map\u003cchar, int\u003e ROMAN = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, }; class Solution { public: int romanToInt(string s) { int ans = 0; for (int i = 0; i + 1 \u003c s.size(); i ++ ) { int x = ROMAN[s[i]], y = ROMAN[s[i + 1]]; ans += x \u003c y ? -x : x; } return ans + ROMAN[s.back()]; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:17","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"12.整数转罗马数字 给你一个整数，将其转为罗马数字 class Solution { static constexpr string R[4][10] = { {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}, // 个位 {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}, // 十位 {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}, // 百位 {\"\", \"M\", \"MM\", \"MMM\"}, // 千位 }; public: string intToRoman(int num) { return R[3][num / 1000] + R[2][num / 100 % 10] + R[1][num / 10 % 10] + R[0][num % 10]; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:18","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"58.最后一个单词的长度 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 class Solution { public: int lengthOfLastWord(string s) { int i = s.length() - 1; while (s[i] == ' ' \u0026\u0026 i \u003e 0) i -- ; int j = i - 1; while (j \u003e= 0 \u0026\u0026 s[j] != ' ') j -- ; return i - j; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:19","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"14.最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 class Solution { public: string longestCommonPrefix(vector\u003cstring\u003e\u0026 strs) { string\u0026 s0 = strs[0]; for (int j = 0; j \u003c s0.size(); j ++ ) { for (string\u0026 s : strs) { if (j == s.size() || s[j] != s0[j]) { return s0.substr(0, j); } } } return s0; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:20","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"151.反转字符串中的单词 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 class Solution { public String reverseWords(String s) { s = s.trim(); // 删除首尾空格 int j = s.length() - 1, i = j; StringBuilder res = new StringBuilder(); while (i \u003e= 0) { while (i \u003e= 0 \u0026\u0026 s.charAt(i) != ' ') i--; // 搜索首个空格 res.append(s.substring(i + 1, j + 1) + \" \"); // 添加单词 while (i \u003e= 0 \u0026\u0026 s.charAt(i) == ' ') i--; // 跳过单词间空格 j = i; // j 指向下个单词的尾字符 } return res.toString().trim(); // 转化为字符串并返回 } } ","date":"2025-03-24","objectID":"/2025/be012dd/:1:21","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"28.找出字符串中第一个匹配项的下标 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 class Solution { public: int strStr(string haystack, string needle) { int m = haystack.size(), n = needle.size(); for (int i = 0; i \u003c haystack.size(); i ++ ) { if (i + n \u003e m) return -1; // 判断两个区间的值是否相同 if (haystack.substr(i, n) == needle) return i; } return -1; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:1:22","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"双指针 ","date":"2025-03-24","objectID":"/2025/be012dd/:2:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"11.盛水最多的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 // 思路和接雨水类似 class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int n = height.size(); int left = 0, right = n - 1; int ans = 0; while (left \u003c right) { ans = max(ans, min(height[left], height[right]) * (right - left)); if (height[left] \u003c height[right]) { left ++ ; } else { right -- ; } } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:2:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"15.三数之和 🔗 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e ans; sort(nums.begin(), nums.end()); // 本质上是过滤所有不可能的情况 for (int i = 0; i \u003c n; i ++ ) { if (i \u0026\u0026 nums[i] == nums[i - 1]) continue; for (int j = i + 1, k = n - 1; j \u003c k; j ++ ) { if (j \u003e i + 1 \u0026\u0026 nums[j] == nums[j - 1]) continue; while (j \u003c k - 1 \u0026\u0026 nums[i] + nums[j] + nums[k - 1] \u003e= 0) k -- ; if (nums[i] + nums[j] + nums[k] == 0) ans.push_back({nums[i], nums[j], nums[k]}); } } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:2:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"滑动窗口 ","date":"2025-03-24","objectID":"/2025/be012dd/:3:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"209.长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [nums_l, nums_l+1, ..., nums_r-1, nums_r] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 class Solution { public: int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) { // 预处理前缀和 int n = nums.size(); vector\u003cint\u003e s(n + 1, 0); for (int i = 1; i \u003c= n; i ++ ) s[i] = s[i - 1] + nums[i - 1]; // 枚举右指针，然后移动左指针 int l = 1; // l 不用回头 int ans = n + 1; for (int r = 1; r \u003c= n; r ++ ) { while ((s[r] - s[l - 1]) \u003e= target) { ans = min(ans, r - l + 1); l ++ ; } } return ans \u003c= n ? ans : 0; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:3:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"3.无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 class Solution { public: int lengthOfLongestSubstring(string s) { // 滑动窗口, unordered_map\u003cchar, int\u003e heap; // 记录每个字符出现过多少次 int res = 0; int left = 0; for (int i = 0; i \u003c s.size(); i ++ ) { heap[s[i]] ++ ; while (heap[s[i]] \u003e 1) { heap[s[left]] -- ; left ++ ; } res = max(res, i - left + 1); } return res; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:3:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"76.最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 class Solution { bool is_covered(int cnt_s[], int cnt_t[]) { for (int i = 'A'; i \u003c= 'Z'; i ++ ) { if (cnt_s[i] \u003c cnt_t[i]) { return false; } } for (int i = 'a'; i \u003c= 'z'; i ++ ) { if (cnt_s[i] \u003c cnt_t[i]) { return false; } } return true; } public: string minWindow(string s, string t) { // 不定长滑动窗口 int cnt_s[128]{}; int cnt_t[128]{}; int min_left = -1; int min_right = s.size(); int ans = s.size(); for (int i = 0; i \u003c t.size(); i ++ ) cnt_t[t[i]] ++ ; for (int i = 0, left = 0; i \u003c s.size(); i ++ ) { cnt_s[s[i]] ++ ; // 已经全覆盖了，右移左端点 while (is_covered(cnt_s, cnt_t)) { if (i - left \u003c min_right - min_left) { min_left = left; min_right = i; } cnt_s[s[left]] -- ; left ++ ; } } if (min_left \u003e= 0) { return s.substr(min_left, min_right - min_left + 1); } return \"\"; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:3:3","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"矩阵 ","date":"2025-03-24","objectID":"/2025/be012dd/:4:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"54.螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 class Solution { public: vector\u003cint\u003e spiralOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { vector\u003cint\u003e res; int m = matrix.size(); int n = matrix[0].size(); vector\u003cvector\u003cint\u003e\u003e st(m + 10, vector\u003cint\u003e(n + 10, 0)); // 用坐标偏移法模拟 int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // 右，下，左，上 int step = 0; // 0, 1, 2, 3 // m 行，n 列 st[0][0] = 1; res.push_back(matrix[0][0]); int cnt = m * n - 1; int i = 0, j = 0; while (cnt -- ) { int x = i + dx[step]; int y = j + dy[step]; // 判断将要走的点有没有越过边界 if (x \u003e= m || x \u003c 0 || y \u003c 0 || y \u003e= n || st[x][y] == 1) { step = (step + 1) % 4; x = i + dx[step]; y = j + dy[step]; } res.push_back(matrix[x][y]); i = x; j = y; } return res; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:4:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"48.旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 class Solution { public: void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { // 先上下颠倒，再矩阵转置 int m = matrix.size(); int n = matrix[0].size(); for (int i = 0; i \u003c m / 2; i ++ ) { for (int j = 0; j \u003c n; j ++ ) { swap(matrix[i][j], matrix[m - 1 - i][j]); } } // 矩阵转置通用公式 for (int i = 0; i \u003c m; i ++ ) { for (int j = i + 1; j \u003c n; j ++ ) { swap(matrix[i][j], matrix[j][i]); } } } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:4:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"哈希表 ","date":"2025-03-24","objectID":"/2025/be012dd/:5:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"128.最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 class Solution { public: int longestConsecutive(vector\u003cint\u003e\u0026 nums) { int ans = 0; unordered_set\u003cint\u003e st(nums.begin(), nums.end()); // 把 nums 转为哈希集合 for (int x : st) { // 遍历哈希集合 if (st.contains(x - 1)) { continue; // 如果 x-1 在哈希集合中，则不以 x 为起点，因为 x-1 为起点计算出来的连续序列一定更长 } // x 是序列的起点 int y = x + 1; while (st.contains(y)) { // 不断查找下一个数是否在哈希集合中 y ++ ; } ans = max(ans, y - x); // 从 x 到 y - 1 一共 y - x 个数 } return ans; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:5:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"链表 ","date":"2025-03-24","objectID":"/2025/be012dd/:6:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"92.反转链表 II 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u003c= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { ListNode dummy{0, head}; ListNode* p0 = \u0026dummy; // 首先维护p0指针，p0指针是待处理段的前一个指针（哨兵节点） for (int i = 0; i \u003c left - 1; i ++ ) { p0 = p0-\u003enext; } ListNode* pre = nullptr; ListNode* cur = p0-\u003enext; for (int i = 0; i \u003c right - left + 1; i ++ ) { ListNode* nxt = cur-\u003enext; cur-\u003enext = pre; pre = cur; cur = nxt; } p0-\u003enext-\u003enext = cur; p0-\u003enext = pre; return dummy.next; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:6:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"25.K 个一组翻转链表 🔗 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { // 统计节点个数 int n = 0; for (ListNode* cur = head; cur; cur = cur-\u003enext) n ++ ; ListNode dummy(0, head); // 哨兵节点，哨兵的下一个节点是head ListNode* p0 = \u0026dummy; ListNode* pre = nullptr; ListNode* cur = head; // k 个一组进行处理 for (; n \u003e= k; n -= k) { // 每组内部就是 反转链表II for (int i = 0; i \u003c k; i ++ ) { ListNode* nxt = cur-\u003enext; // cur不断往右走的同时，维护pre指针和nxt指针 cur-\u003enext = pre; pre = cur; cur = nxt; } // 处理p0指针，p0指针主要是指向每一段被处理链表的哨兵节点（前一个节点） ListNode* nxt = p0-\u003enext; p0-\u003enext-\u003enext = cur; p0-\u003enext = pre; p0 = nxt; } return dummy.next; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:6:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"19.删除链表的倒数第 N 个结点 🔗 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode dummy{0, head}; ListNode* left = \u0026dummy; ListNode* right = \u0026dummy; // 左右指针都先往右走n步 while (n -- ) { left = left-\u003enext; right = right-\u003enext; } // 再同时走一段距离，让右指针指向最后一个节点 while (right-\u003enext) { left = left-\u003enext; right = right-\u003enext; } // 此时 left 下一个节点就是倒数第 n 个节点 ListNode* nxt = left-\u003enext; left-\u003enext = left-\u003enext-\u003enext; delete nxt; return dummy.next; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:6:3","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"82.删除排序链表中的重复元素II 🔗 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return nullptr; ListNode dummy{0, head}; ListNode* cur = \u0026dummy; while (cur-\u003enext \u0026\u0026 cur-\u003enext-\u003enext) { if (cur-\u003enext-\u003eval == cur-\u003enext-\u003enext-\u003eval) { int x = cur-\u003enext-\u003eval; while (cur-\u003enext \u0026\u0026 cur-\u003enext-\u003eval == x) { cur-\u003enext = cur-\u003enext-\u003enext; } } else { cur = cur-\u003enext; } } return dummy.next; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:6:4","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"146.LRU 缓存 🔗 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 用图巧记 struct Node { int key; int value; Node* prev; Node* next; Node(int k = 0, int v = 0) : key(k), value(v) {} }; class LRUCache { private: int capacity; Node* dummy; unordered_map\u003cint, Node*\u003e key_to_node; void remove(Node* x) { x-\u003eprev-\u003enext = x-\u003enext; x-\u003enext-\u003eprev = x-\u003eprev; } void push_front(Node* x) { x-\u003enext = dummy-\u003enext; x-\u003eprev = dummy; x-\u003eprev-\u003enext = x; x-\u003enext-\u003eprev = x; } Node* get_node(int key) { auto it = key_to_node.find(key); if (it == key_to_node.end()) return nullptr; Node* node = key_to_node[key]; remove(node); push_front(node); return node; } public: LRUCache(int capacity) : capacity(capacity), dummy(new Node()) { dummy-\u003eprev = dummy; dummy-\u003enext = dummy; } int get(int key) { Node* node = get_node(key); return node ? node-\u003evalue : -1; } void put(int key, int value) { Node* node = get_node(key); if (node) { node-\u003evalue = value; return; } node = new Node(key, value); key_to_node[key] = node; push_front(node); if (key_to_node.size() \u003e capacity) { Node* back_node = dummy-\u003eprev; key_to_node.erase(back_node-\u003ekey); remove(back_node); delete back_node; } } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:6:5","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"堆 ","date":"2025-03-24","objectID":"/2025/be012dd/:7:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"215.数组中的第K个最大元素 🔗 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 class Solution { public: int findKthLargest(vector\u003cint\u003e\u0026 nums, int target) { // 第 K 个最大元素 // 1 2 3 4，n=4, K=2，则 auto quick_select = [\u0026](this auto\u0026\u0026quick_select, int l, int r, int k) { if (l \u003e= r) return nums[l]; int x = nums[(l + r) / 2], i = l - 1, j = r + 1; while (i \u003c j) { do i ++ ; while (nums[i] \u003c x); do j -- ; while (nums[j] \u003e x); if (i \u003c j) swap(nums[i], nums[j]); } int sl = j - l + 1; if (k \u003c= sl) return quick_select(l, j, k); return quick_select(j + 1, r, k - sl); }; int n = nums.size(); return quick_select(0, n - 1, n - target + 1); } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:7:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"295.数据流的中位数 🔗 中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。 例如 arr = [2,3,4] 的中位数是 3 。 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。 实现 MedianFinder 类: MedianFinder() 初始化 MedianFinder 对象。 void addNum(int num) 将数据流中的整数 num 添加到数据结构中。 double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10^-5 以内的答案将被接受。 class MedianFinder { priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e up; // 小根堆 priority_queue\u003cint\u003e down; // 大根堆 int siz; public: MedianFinder() { siz = 0; // 记录对顶堆中元素大小 } // 对顶堆维护动态中位数 void addNum(int num) { if (down.empty() || num \u003c= down.top()) down.push(num); else up.push(num); siz ++ ; if (down.size() \u003e up.size() + 1) up.push(down.top()), down.pop(); if (up.size() \u003e down.size()) down.push(up.top()), up.pop(); } double findMedian() { if (siz % 2) return down.top(); return (up.top() + down.top()) / 2.0; } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-\u003eaddNum(num); * double param_2 = obj-\u003efindMedian(); */ ","date":"2025-03-24","objectID":"/2025/be012dd/:7:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"一维动态规划 ","date":"2025-03-24","objectID":"/2025/be012dd/:8:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"139.单词拆分 🔗 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 这里用到了字符串哈希来优化 这里有一个隐藏的细节是 “秦九韶算法”，即哈希值的维护。如果不这样写则需要维护一个 p 数组，来进行 a*P^3 + b*P^2 class Solution { public: bool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) { typedef unsigned long long ULL; // 用ULL表示是因为为了对 2^64 取模 unordered_set\u003cULL\u003e hash; const int P = 131; // P进制的经验值，也可以取 13331，可以认为99%的概率不会哈希冲突 for (auto\u0026 s : wordDict) { ULL h = 0; for (auto c : s) { h = h * P + c; // 将词表中的每个词映射至 P 进制，秦九韶算法写法； } hash.insert(h); } int n = s.size(); vector\u003cbool\u003e f(n + 1); s = \" \" + s; f[0] = true; // f[i]表示单词 s 的前 i 个字符能否由 wordDict 中的单词组成，其中边界 f[0] = true for (int i = 0; i \u003c n; i ++ ) { if (f[i]) { // 如果 f[i] = true 并且 s[i + 1:j] 也在 wordDict 中，则 f[j] = true ULL h = 0; for (int j = i + 1; j \u003c= n; j ++ ) { // 查询 s[i + 1:j] 中所有的字符串是否在 wordDict 中出现过 h = h * P + s[j]; if (hash.count(h)) f[j] = true; } } } return f[n]; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:8:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"多维动态规划 ","date":"2025-03-24","objectID":"/2025/be012dd/:9:0","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"120. 三角形最小路径和 🔗 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 class Solution { public: int minimumTotal(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int n = grid.size(); const int INF = 0x3f3f3f3f; vector\u003cvector\u003cint\u003e\u003e f(n + 1, vector\u003cint\u003e(n + 1, -1)); auto dfs = [\u0026](this auto\u0026\u0026 dfs, int x, int y) { int n = grid.size(); if (x == n - 1) return f[x][y] = grid[x][y]; // 不能继续走，f[x][y]的值就是当前点的值 if (f[x][y] != -1) return f[x][y]; int res = INF; if (x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c= x) { res = min(dfs(x + 1, y), dfs(x + 1, y + 1)) + grid[x][y]; } return f[x][y] = res; }; return dfs(0, 0); } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:9:1","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["找工作"],"content":"221.最大正方形 🔗 在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。 class Solution { static const int N = 310; int f[N][N]; public: int maximalSquare(vector\u003cvector\u003cchar\u003e\u003e\u0026 matrix) { int m = matrix.size(), n = matrix[0].size(); memset(f, 0, sizeof f); int a = 0; for (int i = 0; i \u003c m; i ++ ) { for (int j = 0; j \u003c n; j ++ ) { if (matrix[i][j] == '0') continue; if (i == 0 || j == 0) f[i][j] = 1; // 边长最大只能为1 else { // f[i][j]表示以 (i,j) 为右下角的，最大正方形的边长 f[i][j] = min(min(f[i][j - 1], f[i - 1][j]), f[i - 1][j - 1]) + 1; } a = max(a, f[i][j]); } } return a * a; } }; ","date":"2025-03-24","objectID":"/2025/be012dd/:9:2","tags":["算法"],"title":"《面试经典150题》","uri":"/2025/be012dd/"},{"categories":["八股"],"content":"《现代C++并发编程教程》 —— C++并发编程学习笔记（三） ","date":"2025-03-24","objectID":"/2025/80f2e62/:0:0","tags":["C++"],"title":"并发编程（三）","uri":"/2025/80f2e62/"},{"categories":["八股"],"content":"原子操作 这里只简单介绍 std::atomic\u003cbool\u003e（包含在 \u003catomic\u003e 中），最基本的整数原子类型。虽然同样不可复制不可移动，但可以使用非原子的 bool 类型进行构造，初始化为 true 或 false，并且能从非原子的 bool 对象赋值给 std::atomic\u003cbool\u003e： std::atomic\u003cbool\u003e b{ true }; b = false; ","date":"2025-03-24","objectID":"/2025/80f2e62/:1:0","tags":["C++"],"title":"并发编程（三）","uri":"/2025/80f2e62/"},{"categories":["八股"],"content":"线程池 抽象的来说，可以当做是一个池子中存放了一堆线程，故称作线程池。简而言之，线程池是指代一组预先创建的、可以复用的线程集合。这些线程由线程池管理，用于执行多个任务而无需频繁地创建和销毁线程。 这是一个典型的线程池结构。线程池包含一个任务队列，当有新任务加入时，调度器会将任务分配给线程池中的空闲线程进行执行。线程在执行完任务后会进入休眠状态，等待调度器的下一次唤醒。当有新的任务加入队列，并且有线程处于休眠状态时，调度器会唤醒休眠的线程，并分配新的任务给它们执行。线程执行完新任务后，会再次进入休眠状态，直到有新的任务到来，调度器才可能会再次唤醒它们。 图中线程1 就是被调度器分配了任务1，执行完毕后休眠，然而新任务的到来让调度器再次将它唤醒，去执行任务6，执行完毕后继续休眠。 使用线程池的益处我们已经加粗了，然而这其实并不是“线程池”独有的，任何创建和销毁存在较大开销的设施，都可以进行所谓的“池化”。 常见的还有：套接字连接池、数据库连接池、内存池、对象池。 下面简单介绍下常用的线程池。 ","date":"2025-03-24","objectID":"/2025/80f2e62/:2:0","tags":["C++"],"title":"并发编程（三）","uri":"/2025/80f2e62/"},{"categories":["八股"],"content":"boost::asio::thread_pool boost::asio::thread_pool 是 Boost.Asio 库提供的一种线程池实现。 Asio 是一个跨平台的 C++ 库，用于网络和低级 I/O 编程，使用 现代C++ 方法为开发人员提供一致的异步模型。 使用方法： 创建线程池对象，指定或让 Asio 自动决定线程数量。 提交任务：通过 boost::asio::post 函数模板提交任务到线程池中。 阻塞，直到池中的线程完成任务。 #include \u003cboost/asio.hpp\u003e #include \u003ciostream\u003e std::mutex m; void print_task(int n) { std::lock_guard\u003cstd::mutex\u003e lc{ m }; std::cout \u003c\u003c \"Task \" \u003c\u003c n \u003c\u003c \" is running on thr: \" \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; } int main() { boost::asio::thread_pool pool{ 4 }; // 创建一个包含 4 个线程的线程池 for (int i = 0; i \u003c 10; ++i) { boost::asio::post(pool, [i] { print_task(i); }); } pool.join(); // 等待所有任务执行完成 } 详情见 boost/asio 的使用，这里不再展开。 ","date":"2025-03-24","objectID":"/2025/80f2e62/:2:1","tags":["C++"],"title":"并发编程（三）","uri":"/2025/80f2e62/"},{"categories":["八股"],"content":"实现线程池 实现一个普通的能够满足日常开发需求的线程池实际上非常简单，只需要不到一百行代码。其实绝大部分开发者使用线程池，只是为了不重复多次创建线程罢了。所以只需要一个提供一个外部接口，可以传入任务到任务队列，然后安排线程去执行。无非是使用条件变量、互斥量、原子标志位，这些东西，就足够编写一个满足绝大部分业务需求的线程池。 我们先编写一个最基础的线程池，首先确定它的数据成员： class ThreadPool { std::mutex mutex_; // 用于保护共享资源（如任务队列）在多线程环境中的访问，避免数据竞争。 std::condition_variable cv_; // 用于线程间的同步，允许线程等待特定条件（如新任务加入队列）并在条件满足时唤醒线程。 std::atomic\u003cbool\u003e stop_; // 指示线程池是否停止。 std::atomic\u003cstd::size_t\u003e num_threads_; // 表示线程池中的线程数量。 std::queue\u003cTask\u003e tasks_; // 任务队列，存储等待执行的任务，任务按提交顺序执行。 std::vector\u003cstd::thread\u003e pool_; // 线程容器，存储管理线程对象，每个线程从任务队列中获取任务并执行。 }; 标头依赖： #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cmutex\u003e #include \u003ccondition_variable\u003e #include \u003cfuture\u003e #include \u003catomic\u003e #include \u003cqueue\u003e #include \u003cvector\u003e #include \u003csyncstream\u003e #include \u003cfunctional\u003e 提供构造析构函数，以及一些外部接口：submit()、start()、stop()、join()，也就完成了： inline std::size_t default_thread_pool_size()noexcept { std::size_t num_threads = std::thread::hardware_concurrency() * 2; num_threads = num_threads == 0 ? 2 : num_threads; return num_threads; } class ThreadPool { private: std::mutex mutex_; std::condition_variable cv_; std::atomic\u003cbool\u003e stop_; std::atomic\u003cstd::size_t\u003e num_threads_; std::queue\u003cTask\u003e tasks_; std::vector\u003cstd::thread\u003e pool_; public: using Task = std::packaged_task\u003cvoid()\u003e; ThreadPool(const ThreadPool\u0026) = delete; ThreadPool\u0026 operator=(const ThreadPool\u0026) = delete; ThreadPool(std::size_t num_thread = default_thread_pool_size()) : stop_{ false }, num_threads_{ num_thread } { start(); } ~ThreadPool() { stop(); } void stop() { stop_.store(true); cv_.notify_all(); for (auto\u0026 thread : pool_) { if (thread.joinable()) { thread.join(); } } pool_.clear(); } template\u003ctypename F, typename... Args\u003e std::future\u003cstd::invoke_result_t\u003cstd::decay_t\u003cF\u003e, std::decay_t\u003cArgs\u003e...\u003e\u003e submit(F\u0026\u0026 f, Args\u0026\u0026...args) { using RetType = std::invoke_result_t\u003cstd::decay_t\u003cF\u003e, std::decay_t\u003cArgs\u003e...\u003e; if (stop_.load()) { throw std::runtime_error(\"ThreadPool is stopped\"); } auto task = std::make_shared\u003cstd::packaged_task\u003cRetType()\u003e\u003e( std::bind(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)...)); std::future\u003cRetType\u003e ret = task-\u003eget_future(); { std::lock_guard\u003cstd::mutex\u003e lc{ mutex_ }; tasks_.emplace([task] {(*task)(); }); } cv_.notify_one(); return ret; } void start() { for (std::size_t i = 0; i \u003c num_threads_; ++i) { pool_.emplace_back([this] { while (!stop_) { Task task; { std::unique_lock\u003cstd::mutex\u003e lc{ mutex_ }; cv_.wait(lc, [this] {return stop_ || !tasks_.empty(); }); if (tasks_.empty()) return; task = std::move(tasks_.front()); tasks_.pop(); } task(); } }); } } }; 测试 demo: int main() { ThreadPool pool{ 4 }; // 创建一个有 4 个线程的线程池 std::vector\u003cstd::future\u003cint\u003e\u003e futures; // future 集合，获取返回值 for (int i = 0; i \u003c 10; ++i) { futures.emplace_back(pool.submit(print_task, i)); } for (int i = 0; i \u003c 10; ++i) { futures.emplace_back(pool.submit(print_task2, i)); } int sum = 0; for (auto\u0026 future : futures) { sum += future.get(); // get() 成员函数 阻塞到任务执行完毕，获取返回值 } std::cout \u003c\u003c \"sum: \" \u003c\u003c sum \u003c\u003c '\\n'; } // 析构自动 stop() 可能的运行结果： Task 0 is running on thr: 6900 Task 1 is running on thr: 36304 Task 5 is running on thr: 36304 Task 3 is running on thr: 6900 Task 7 is running on thr: 6900 Task 2 is running on thr: 29376 Task 6 is running on thr: 36304 Task 4 is running on thr: 31416 🐢🐢🐢 1 🐉🐉🐉 Task 9 is running on thr: 29376 🐢🐢🐢 0 🐉🐉🐉 Task 8 is running on thr: 6900 🐢🐢🐢 2 🐉🐉🐉 🐢🐢🐢 6 🐉🐉🐉 🐢🐢🐢 4 🐉🐉🐉 🐢🐢🐢 5 🐉🐉🐉 🐢🐢🐢 3 🐉🐉🐉 🐢🐢🐢 7 🐉🐉🐉 🐢🐢🐢 8 🐉🐉🐉 🐢🐢🐢 9 🐉🐉🐉 sum: 90 它支持任意可调用类型，当然也包括非静态成员函数。我们使用了 std::decay_t，所以参数的传递其实是按值复制，而不是引用传递，这一点和大部分库的设计一致。示例如下： struct X { void f(const int\u0026 n) const { std::osyncstream{ std::cout } \u003c\u003c \u0026n \u003c\u003c '\\n'; } }; int main() { ThreadPool pool{ 4 }; // 创建一个有 4 个线程的线程池 X x; int n = 6; std::cout \u003c\u003c \u0026n \u003c\u003c '\\n'; auto t = pool.submit(\u0026X::f, \u0026x, n); // 默认复制，地址不同 auto t2 = pool.submit(\u0026X::f, \u0026x, std::ref(n)); t.wait(); t2.wait(); } // 析构自动 stop() 我们的线程池的 submit 成员函数在传递参数的行为上，与先前介绍的 std::thread 和 std::async 等设施基本一致。 构造函数和析构函数： 构造函数：初始化线程池并启动线程。 析构函数：停止线程池并等待所有线程结束。 外部接口： stop()：停止线程池，通知所有线程退出（不会等待所有任务执行完毕）。 submit()：将任务提交到任务","date":"2025-03-24","objectID":"/2025/80f2e62/:2:2","tags":["C++"],"title":"并发编程（三）","uri":"/2025/80f2e62/"},{"categories":["八股"],"content":"《现代C++并发编程教程》 —— C++并发编程学习笔记（二） ","date":"2025-03-24","objectID":"/2025/4b155bd/:0:0","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"等待事件或条件 假设你正在一辆夜间运行的地铁上，那么你要如何在正确的站点下车呢？ 1.一直不休息，每一站都能知道，这样就不会错过你要下车的站点，但是这会很疲惫。 这种方法被称为“忙等待（busy waiting）”也称 “自旋“。 bool flag = false; std::mutex m; void wait_for_flag() { std::unique_lock\u003cstd::mutex\u003e lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 lk.lock(); // 2 上锁互斥量 } } 2.可以看一下时间，估算一下地铁到达目的地的时间，然后设置一个稍早的闹钟，就休息。这个方法听起来还行，但是你可能被过早的叫醒，甚至估算错误导致坐过站，又或者闹钟没电了睡过站。 第二种方法就是加个延时，这种实现进步了很多，减少浪费的执行时间，但很难确定正确的休眠时间。这会影响到程序的行为，在需要快速响应的程序中就意味着丢帧或错过了一个时间片。循环中，休眠 ② 前函数对互斥量解锁 ①，再休眠结束后再对互斥量上锁，让另外的线程有机会获取锁并设置标识（因为修改函数和等待函数共用一个互斥量）。 void wait_for_flag() { std::unique_lock\u003cstd::mutex\u003e lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2 休眠 lk.lock(); // 3 上锁互斥量 } } 3.事实上最简单的方式是，到站的时候有人或者其它东西能将你叫醒（比如手机的地图，到达设置的位置就提醒）。 第三种方式（也是最好的）实际上就是使用条件变量了。通过另一线程触发等待事件的机制是最基本的唤醒方式，这种机制就称为“条件变量”。 C++ 标准库对条件变量有两套实现：std::condition_variable 和 std::condition_variable_any，这两个实现都包含在 \u003ccondition_variable\u003e 这个头文件中。 condition_variable_any 类是 std::condition_variable 的泛化。相对于只在 std::unique_lock\u003cstd::mutex\u003e 上工作的 std::condition_variable，condition_variable_any 能在任何满足 可基本锁定(BasicLockable) 要求的锁上工作，所以增加了 _any 后缀。显而易见，这种区分必然是 any 版更加通用但是却有更多的性能开销。所以通常首选 std::condition_variable。有特殊需求，才会考虑 std::condition_variable_any。 std::mutex mtx; // 创建了一个互斥量，用于保护共享数据的访问，确保在多线程环境下的数据同步。 std::condition_variable cv; // 创建了一个条件变量，用于线程间的同步，当条件不满足时，线程可以等待，直到条件满足时被唤醒。 bool arrived = false; // 设置了一个标志位，表示是否到达目的地。 void wait_for_arrival() { std::unique_lock\u003cstd::mutex\u003e lck(mtx); // 使用互斥量创建了一个独占锁。 cv.wait(lck, []{ return arrived; }); // 阻塞当前线程，释放（unlock）锁，直到条件被满足。 std::cout \u003c\u003c \"到达目的地，可以下车了！\" \u003c\u003c std::endl; } void simulate_arrival() { std::this_thread::sleep_for(std::chrono::seconds(5)); // 模拟地铁到站，假设5秒后到达目的地 { std::lock_guard\u003cstd::mutex\u003e lck(mtx); arrived = true; // 设置条件变量为 true，表示到达目的地 } cv.notify_one(); // 通知等待的线程 } 这样，当 simulate_arrival 函数执行后，arrived 被设置为 true，并且通过 cv.notify_one() 唤醒了等待在条件变量上的线程，从而使得 wait_for_arrival 函数中的等待结束，可以执行后续的操作，即输出提示信息。 条件变量的 wait 成员函数有两个版本，以上代码使用的就是第二个版本，传入了一个谓词。 void wait(std::unique_lock\u003cstd::mutex\u003e\u0026 lock); // 1 template\u003cclass Predicate\u003e void wait(std::unique_lock\u003cstd::mutex\u003e\u0026 lock, Predicate pred); // 2 ②等价于： while (!pred()) wait(lock); 第二个版本只是对第一个版本的包装，等待并判断谓词，会调用第一个版本的重载。这可以避免 虚假唤醒 条件变量虚假唤醒是指在使用条件变量进行线程同步时，有时候线程可能会在没有收到通知的情况下被唤醒。问题取决于程序和系统的具体实现。解决方法很简单，在循环中等待并判断条件可一并解决。使用 C++ 标准库则没有这个烦恼了。 ","date":"2025-03-24","objectID":"/2025/4b155bd/:1:0","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"线程安全的队列 这里介绍一个更为复杂的示例，用于巩固条件变量的学习。在实现一个线程安全的队列过程中，需要注意两点内容： 当执行 push 操作时，需要确保没有其他线程正在执行 push 或 pop 操作；同样，在执行 pop 操作时，也需要确保没有其他线程正在执行 push 或 pop 操作。 当队列为空时，不应该执行 pop 操作。因此，我们需要使用条件变量来传递一个谓词，以确保在执行 pop 操作时队列不为空。 以下是一个线程安全的模版类 threadsafe_queue： template\u003ctypename T\u003e class threadsafe_queue { mutable std::mutex m; // 互斥量，用于保护队列操作的独占访问 std::condition_variable data_cond; // 条件变量，用于在队列为空时等待 std::queue\u003cT\u003e data_queue; // 实际存储数据的队列 public: threadsafe_queue() {} // 无参构造 void push(T new_value) { { std::lock_guard\u003cstd::mutex\u003e lk { m }; data_queue.push(new_value); } data_cond.notify_one(); } // 从队列中弹出元素（阻塞直到队列不为空） void pop(T\u0026 value) { std::unique_lock\u003cstd::mutex\u003e lk{ m }; data_cond.wait(lk, [this] {return !data_queue.empty(); }); // 这里的 this 表示按值传递 this，见 lambda 表达式用法 value = data_queue.front(); data_queue.pop(); } // 从队列中弹出元素（阻塞直到队列不为空），并返回一个指向弹出元素的 shared_ptr std::shared_ptr\u003cT\u003e pop() { std::unique_lock\u003cstd::mutex\u003e lk{ m }; data_cond.wait(lk, [this] {return !data_queue.empty(); }); std::shared_ptr\u003cT\u003e res { std::make_shared\u003cT\u003e(data_queue.front()) }; data_queue.pop(); return res; } bool empty()const { std::lock_guard\u003cstd::mutex\u003e lk (m); return data_queue.empty(); } }; ","date":"2025-03-24","objectID":"/2025/4b155bd/:2:0","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"使用 future 举个例子，我们在车站等车，你可能会做一些别的事情打发时间，比如学习现代C++并发编程教程、玩手机等，但始终在等待一件事情：车到站。 C++ 标准库将这种事件称为 future。它用于处理线程中需要等待某个事件的情况，线程知道预期结果。等待的同时也可以执行其它的任务。 C++ 标准库有两种 future，都声明在 \u003cfuture\u003e 头文件中：独占的 std::future 、共享的 std::shared_future。它们的区别与 std::unique_ptr 和 std::shared_ptr 类似。std::future 只能与单个指定事件关联，而 std::shared_future 能关联多个事件。它们都是模板，它们的模板类型参数，就是其关联的事件（函数）的返回类型。当多个线程需要访问一个独立 future 对象时， 必须使用互斥量或类似同步机制进行保护。而多个线程访问同一共享状态，若每个线程都是通过其自身的 shared_future 对象副本进行访问，则是安全的。 最简单有效的使用是，我们先前讲的 std::thread 在线程中执行任务是没有返回值的，这个问题就能使用 future 解决。 ","date":"2025-03-24","objectID":"/2025/4b155bd/:3:0","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"创建异步任务获取返回值 假设需要执行一个耗时任务并获取其返回值，但是并不急切的需要它。那么就可以启动新线程计算，然而 std::thread 没提供直接从线程获取返回值的机制。所以我们可以使用 std::async 函数模板。 使用 std::async 启动一个异步任务，它会返回一个 std::future 对象，这个对象和任务关联，将持有最终计算出来的结果。当需要任务执行完的结果的时候，只需要调用 get() 成员函数，就会阻塞直到 future 为就绪为止（即任务执行完毕），返回执行结果。valid() 成员函数检查 future 当前是否关联共享状态，即是否当前关联任务。还未关联，或者任务已经执行完（调用了 get()、set()），都会返回 false。 #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cfuture\u003e // 引入 future 头文件 int task(int n) { std::cout \u003c\u003c \"异步任务 ID: \" \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; return n * n; } int main() { std::future\u003cint\u003e future = std::async(task, 10); std::cout \u003c\u003c \"main: \" \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; std::cout \u003c\u003c std::boolalpha \u003c\u003c future.valid() \u003c\u003c '\\n'; // true std::cout \u003c\u003c future.get() \u003c\u003c '\\n'; std::cout \u003c\u003c std::boolalpha \u003c\u003c future.valid() \u003c\u003c '\\n'; // false } 关于 std::async 的参数传递，这里不再展开记录，用时再查。 ","date":"2025-03-24","objectID":"/2025/4b155bd/:3:1","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"信号量 信号量是一个非常轻量简单的同步设施（在 C++ 20中被引入），它维护一个计数，这个计数不能小于 0。信号量提供两种基本操作：释放（增加计数）和等待（减少计数）。如果当前信号量的计数值为 0，那么执行“等待”操作的线程将会一直阻塞，直到计数大于 0，也就是其它线程执行了 “释放” 操作。 C++ 提供了两个信号量类型：std::counting_semaphore 与 std::binary_semaphore，定义在 \u003csemaphore\u003e 中。其中 binary_semaphore 只是 counting_semaphore 的一个特化别名（其 LeastMaxValue 为1，LeastMaxValue 意思是信号量维护的计数最大值。）： using binary_semaphore = counting_semaphore\u003c1\u003e; 举个具体使用信号量的例子： // 全局二元信号量对象 // 设置对象初始计数为 0 std::binary_semaphore smph_signal_main_to_thread{ 0 }; std::binary_semaphore smph_signal_thread_to_main{ 0 }; void thread_proc() { smph_signal_main_to_thread.acquire(); std::cout \u003c\u003c \"[线程] 获得信号\" \u003c\u003c std::endl; std::this_thread::sleep_for(3s); std::cout \u003c\u003c \"[线程] 发送信号\\n\"; smph_signal_thread_to_main.release(); } int main() { std::jthread thr_worker{ thread_proc }; std::cout \u003c\u003c \"[主] 发送信号\\n\"; smph_signal_main_to_thread.release(); smph_signal_thread_to_main.acquire(); std::cout \u003c\u003c \"[主] 获得信号\\n\"; } 结果： [主] 发送信号 [线程] 获得信号 [线程] 发送信号 [主] 获得信号 acquire 函数就是我们先前说的“等待”（原子地减少计数），release 函数就是\"释放\"（原子地增加计数）。 提示 信号量常用于 发信/提醒 而非互斥，通过初始化该信号量为 0 从而阻塞尝试 acquire() 的接收者，直至提醒者通过调用 release(n) “发信”。在此方面可把信号量当作条件变量的替代品，通常它有更好的性能。 假设我们有一个 Web 服务器，它只能处理有限数量的并发请求。为了防止服务器过载，我们可以使用信号量来限制并发请求的数量。 // 定义一个信号量，最大并发数为 3 std::counting_semaphore\u003c3\u003e semaphore{ 3 }; // counting_semaphore 轻量同步原语，允许同一资源进行多个并发的访问，至少允许 LeastMaxValue 个同时访问者 void handle_request(int request_id) { // 请求到达，尝试获取信号量 std::cout \u003c\u003c \"进入 handle_request 尝试获取信号量\\n\"; semaphore.acquire(); std::cout \u003c\u003c \"成功获取信号量\\n\"; // 此处延时三秒可以方便测试，会看到先输出 3 个“成功获取信号量”，因为只有三个线程能成功调用 acquire，剩余的会被阻塞 std::this_thread::sleep_for(3s); // 模拟处理时间 std::random_device rd; std::mt19937 gen{ rd() }; std::uniform_int_distribution\u003c\u003e dis(1, 5); int processing_time = dis(gen); std::this_thread::sleep_for(std::chrono::seconds(processing_time)); std::cout \u003c\u003c std::format(\"请求 {} 已被处理\\n\", request_id); semaphore.release(); } int main() { // 模拟 10 个并发请求 std::vector\u003cstd::jthread\u003e threads; for (int i = 0; i \u003c 10; ++i) { threads.emplace_back(handle_request, i); } } 牢记信号量的基本的概念不变，计数的值不能小于 0，如果当前信号量的计数值为 0，那么执行 “等待”（acquire） 操作的线程将会一直阻塞。明白这点，那么就都不存在问题。 ","date":"2025-03-24","objectID":"/2025/4b155bd/:4:0","tags":["C++"],"title":"并发编程（二）","uri":"/2025/4b155bd/"},{"categories":["八股"],"content":"《现代C++并发编程教程》 —— C++并发编程学习笔记（一） ","date":"2025-03-23","objectID":"/2025/acc27a1/:0:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"启动线程 #include \u003ciostream\u003e #include \u003cthread\u003e void hello() { printf(\"hello world!\\n\"); } int main() { std::thread my_thread(hello); } 可以传入函数对象，如上例所示。也可以传入类或者其他重载了 () （callable）运算符的对象，例如： class task { public: void operator()() const { do_something(); do_something_else(); } }; task f; std::thread my_thread(f); 但这里需要注意一个问题，由于 C++ 的语法问题，有时会造成歧义，例如： std::thread my_thread(task()); // 这会被认为是声明了一个返回值为 thread 的，名为 my_thread 的函数 这里最好使用 {} 运算符来创建一个 thread 对象，如： std::thread my_thread{task()}。同时也可以用匿名函数（lambda表达式）来创建线程： #include \u003ciostream\u003e #include \u003cthread\u003e int main() { std::thread thread{ [] {std::cout \u003c\u003c \"Hello World!\\n\"; } }; thread.join(); } 当一个线程对象创建时（即 std::thread 对象构造时）就开始执行传入的函数 f 了。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:1:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"线程管理 启动线程后（构造 std::thread 对象），我们必须在线程的生命周期结束之前，即 std::thread::~thread 调用之前，决定它的执行策略，包括 join() 和 detach()。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:2:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"join() 其中 join() 表示将阻塞关联的线程，直至执行完毕。内部实现会让 std::thread::joinable() 返回 false。否则会返回 true，执行 std::terminate()。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:2:1","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"detach() 执行了 detach() 后，表示线程对象放弃了对线程资源的所有权，允许此线程的独立运行，在线程退出时释放所有分配的资源。通常不建议使用 detach()，可以用 join() 替代。 可以提供一个类，RAII（Resource Acquisition Initilization）地确保线程执行完成，线程对象正常析构释放资源： class thread_guard { std::thread\u0026 m_t; public: explicit thread_guard(std::thread\u0026 t) : m_t{ t } {} ~thread_guard() { std::puts(\"析构\"); // 打印日志 不用在乎 if (m_t.joinable()) { // 线程对象当前关联了活跃线程 m_t.join(); } } thread_guard(const thread_guard\u0026) = delete; thread_guard\u0026 operator=(const thread_guard\u0026) = delete; }; void f() { int n = 0; std::thread t{ func{n},10 }; thread_guard g(t); f2(); // 可能抛出异常 } ","date":"2025-03-23","objectID":"/2025/acc27a1/:2:2","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"传递参数 向可调用对象传递参数，只需要将这些参数作为 std::thread 的构造参数即可。 需要注意的是，这些参数会复制到新线程的内存空间中，即使函数中的参数是引用，依然实际是复制。 void f(int, const int\u0026 a); int n = 1; std::thread t{ f, 3, n }; 线程对象 t 的构造没有问题，可以通过编译，但是这个 n 实际上并没有按引用传递，而是按值复制的。如果我们的 f 的形参类型不是 const 的引用，则会产生一个编译错误。可以用标准库的 std::ref、std::cref 函数模版。 void f(int, int\u0026 a) { std::cout \u003c\u003c \u0026a \u003c\u003c '\\n'; } int main() { int n = 1; std::cout \u003c\u003c \u0026n \u003c\u003c '\\n'; std::thread t { f, 3, std::ref(n) }; t.join(); } ","date":"2025-03-23","objectID":"/2025/acc27a1/:3:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"共享数据 我们都知道线程通信的方式有临界区、互斥量、信号量、条件变量、读写锁： 临界区：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。在临界区中，通常会使用同步机制，比如我们要讲的互斥量（Mutex） 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 信号量：计数器，允许多个线程同时访问同一个资源。 条件变量：通过条件变量通知操作的方式来保持多线程同步。 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。 如果有以下情况，出现数据竞争情况。 std::vector\u003cint\u003e v; void f() { v.emplace_back(1); } void f2() { v.erase(v.begin()); } int main() { std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); std::cout \u003c\u003c v.size() \u003c\u003c '\\n'; // 有时出现段错误，有时输出0，不稳定的输出结果 } 这里我们可以用互斥量来解决这一问题。 #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e #include \u003cvector\u003e std::mutex m; std::vector\u003cint\u003e v; void f() { m.lock(); v.emplace_back(1); m.unlock(); } void f2() { m.lock(); v.erase(v.begin()); m.unlock(); } int main() { std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); std::cout \u003c\u003c v.size() \u003c\u003c '\\n'; // 稳定输出0 } 另外一个例子，使用 mutex 互斥量前： void f() { // this_thread::get_id() 表示获取当前线程的唯一标识符，以便在多线程程序中区分不同的线程。 std::cout \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; } int main() { std::vector\u003cstd::thread\u003e threads; for (std::size_t i = 0; i \u003c 10; ++i) threads.emplace_back(f); for (auto\u0026 thread : threads) thread.join(); } 这里有一个点，正好说明一下 push_back() 和 emplace_back() 的区别 如果要用 push_back，则需要先构造一个 thread 临时对象：threads.push_back(std::thread(f)); 而如果用 emplace_back，该方法允许在 vector 末尾直接构造对象，而无需创建临时对象。它接受构造函数的参数，并在适当的位置直接调用构造函数。这样可以减少不必要的对象创建和移动操作，提高性能：threads.emplace_back(f); std::mutex 和 std::shared_mutex 区别 std::mutex： 独占锁，同一时刻只能有一个线程访问线程资源 std::shared_mutex：读写锁，允许多个线程同时读取，但写入时会独占（C++ 17）引入 使用后： #include \u003cmutex\u003e // 必要标头 std::mutex m; void f() { m.lock(); std::cout \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; m.unlock(); } int main() { std::vector\u003cstd::thread\u003ethreads; for (std::size_t i = 0; i \u003c 10; ++i) threads.emplace_back(f); for (auto\u0026 thread : threads) thread.join(); } 当多个线程执行函数 f 的时候，只有一个线程能成功调用 lock() 给互斥量上锁，其他所有的线程 lock() 的调用将阻塞执行，直至获得锁。第一个调用 lock() 的线程得以继续往下执行，执行我们的 std::cout 输出语句，不会有任何其他的线程打断这个操作。直到线程执行 unlock()，就解锁了互斥量。那么其他线程此时也就能再有一个成功调用 lock。至于是哪个线程才会成功调用，这个是由操作系统调度决定的 这里我理解的是，“锁” 是一种广泛的概念，可以有多种实现方式，c++ 中的互斥量 mutex 可以用来实现锁 ","date":"2025-03-23","objectID":"/2025/acc27a1/:4:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"std::lock_guard 一般来说，不建议直接使用互斥量 mutex 显式地进行 lock() 和 unlock()。可以用 C++11 标准引入的管理类 std::lock_guard: void f() { std::lock_guard\u003cstd::mutex\u003e lc{ m }; // 等价于 m.lock()，超出作用域调用析构来 unlock std::cout \u003c\u003c std::this_thread::get_id() \u003c\u003c '\\n'; } std::lock_guard 实现比较简单，可以看它在 MSVC STL 中的实现。 我们要尽可能的让互斥量上锁的粒度小，只用来确保必须的共享资源的线程安全。 “粒度”通常用于描述锁定的范围大小，较小的粒度意味着锁定的范围更小，因此有更好的性能和更少的竞争。 比如有的时候可以看到这样的写法： void f() { //code.. { std::lock_guard\u003cstd::mutex\u003e lc{ m }; // 涉及共享资源的修改的代码... } //code.. } 使用 {} 创建了一个块作用域，限制了对象 lc 的生存期，进入作用域构造 lock_guard 的时候上锁（lock），离开作用域析构的时候解锁（unlock）。 举一个具体的例子： std::mutex m; void add_to_list(int n, std::list\u003cint\u003e\u0026 list) { std::vector\u003cint\u003e numbers(n + 1); std::iota(numbers.begin(), numbers.end(), 0); // iota是对vector进行递增（默认递增1）赋值的方法，0是起始值 int sum = std::accumulate(numbers.begin(), numbers.end(), 0); // 0是起始值 { std::lock_guard\u003cstd::mutex\u003e lc{ m }; list.push_back(sum); } } void print_list(const std::list\u003cint\u003e\u0026 list){ std::lock_guard\u003cstd::mutex\u003e lc{ m }; for(const auto\u0026 i : list){ std::cout \u003c\u003c i \u003c\u003c ' '; } std::cout \u003c\u003c '\\n'; } // ...... // std::list\u003cint\u003e list; std::thread t1{ add_to_list,i,std::ref(list) }; // 上面提到过，传参即使是引用，也会被复制，需要用 std::ref std::thread t2{ add_to_list,i,std::ref(list) }; std::thread t3{ print_list,std::cref(list) }; // const 引用需要用 std::cref std::thread t4{ print_list,std::cref(list) }; t1.join(); t2.join(); t3.join(); t4.join(); 这里的共享数据只有 list， 先看 add_to_list，只有 list.push_back(sum) 涉及到了对共享数据的修改，需要进行保护，因此我们用 {} 包裹。 函数 print_list() 打印 list，给整个函数上锁，同一时刻只能有一个线程执行。我们代码是多个线程执行这两个函数，两个函数共享了一个锁，这样确保了当执行函数 print_list() 打印的时候，list 的状态是确定的。打印函数 print_list 和 add_to_list 函数的修改操作同一时间只能有一个线程在执行。print_list() 不可能看到正在被 add_to_list() 修改的 list。 至于到底哪个函数哪个线程会先执行，执行多少次，这些都由操作系统调度决定，也完全有可能连续 4 次都是执行函数 print_list 的线程成功调用 lock，会打印出了一样的值，这都很正常。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:4:1","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"try_lock try_lock 是互斥量中的一种尝试上锁的方式。与常规的 lock 不同，try_lock 会尝试上锁，但如果锁已经被其他线程占用，则不会阻塞当前线程，而是立即返回。 它的返回类型是 bool ，如果上锁成功就返回 true，失败就返回 false。 这种方法在多线程编程中很有用，特别是在需要保护临界区的同时，又不想线程因为等待锁而阻塞的情况下。 std::mutex mtx; void thread_function(int id) { // 尝试加锁 if (mtx.try_lock()) { std::cout \u003c\u003c \"线程：\" \u003c\u003c id \u003c\u003c \" 获得锁\" \u003c\u003c std::endl; // 临界区代码 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作 mtx.unlock(); // 解锁 std::cout \u003c\u003c \"线程：\" \u003c\u003c id \u003c\u003c \" 释放锁\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"线程：\" \u003c\u003c id \u003c\u003c \" 获取锁失败 处理步骤\" \u003c\u003c std::endl; } } 如果有两个线程运行这段代码，必然有一个线程无法成功上锁，要走 else 的分支。 std::thread t1(thread_function, 1); std::thread t2(thread_function, 2); t1.join(); t2.join(); 可能的运行结果： 线程：1 获得锁 线程：2 获取锁失败 处理步骤 线程：1 释放锁 小心 切勿将受保护数据的指针或引用传递到互斥量作用域之外，不然保护将形同虚设。下面是一个具体例子 class Data { int a{}; std::string b{}; public: void do_something() { // 修改数据成员等... } }; class Data_wrapper { Data data; std::mutex m; public: template\u003cclass Func\u003e void process_data(Func func) { std::lock_guard\u003cstd::mutex\u003e lc{m}; func(data); // 受保护数据传递给函数 } }; Data* p = nullptr; void malicious_function(Data\u0026 protected_data) { p = \u0026protected_data; // 受保护的数据被传递到外部 } Data_wrapper d; void foo() { d.process_data(malicious_function); // 传递了一个恶意的函数 p-\u003edo_something(); // 在无保护的情况下访问保护数据 } 成员函数模板 process_data 看起来一点问题也没有，使用 std::lock_guard 对数据做了保护，但是调用方传递了 malicious_function 这样一个恶意的函数，使受保护数据传递给外部，可以在没有被互斥量保护的情况下调用 do_something()。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:4:2","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"死锁：问题与解决 两个线程需要对它们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个线程的互斥量解锁。因为它们都在等待对方释放互斥量，没有线程工作。 这种情况就是死锁。一般只有多个互斥量才会遇到死锁问题 死锁发生的四个必要条件 互斥（资源一次只能被一个线程占用） 持有且等待（线程已持有资源，并等待其他资源） 不可抢占（已持有资源不能被强制释放） 循环等待（多个线程互相等待对方释放资源） 避免死锁的一般建议是让两个互斥量以相同的顺序上锁，总在互斥量 B 之前锁住互斥量 A，就通常不会死锁。反面示例： std::mutex m1,m2; std::size_t n{}; void f() { std::lock_guard\u003cstd::mutex\u003e lc1{ m1 }; std::lock_guard\u003cstd::mutex\u003e lc2{ m2 }; ++n; } void f2() { std::lock_guard\u003cstd::mutex\u003e lc1{ m2 }; std::lock_guard\u003cstd::mutex\u003e lc2{ m1 }; ++n; } f 与 f2 因为互斥量上锁顺序不同，就有死锁风险。函数 f 先锁定 m1，然后再尝试锁定 m2，而函数 f2 先锁定 m2 再锁定 m1 。如果两个线程同时运行，它们就可能（具体获得锁的顺序由操作系统调度决定，上面阐述过）会彼此等待对方释放其所需的锁，从而造成死锁。 但有时候即使固定了锁的顺序，依旧会产生问题。当有多个互斥量保护同一个类的对象时，对于相同类型的两个不同对象进行数据的交换操作，为了保证数据交换的正确性，就要避免其它线程修改，确保每个对象的互斥量都锁住自己要保护的区域。如果按照前面的的选择一个固定的顺序上锁解锁，则毫无意义，比如： struct X { X(const std::string\u0026 str) :object{ str } {} friend void swap(X\u0026 lhs, X\u0026 rhs); private: std::string object; std::mutex m; }; void swap(X\u0026 lhs, X\u0026 rhs) { if (\u0026lhs == \u0026rhs) return; std::lock_guard\u003cstd::mutex\u003e lock1{ lhs.m }; std::lock_guard\u003cstd::mutex\u003e lock2{ rhs.m }; swap(lhs.object, rhs.object); } 考虑用户调用的时候将参数交换，就会产生死锁： X a{ \"🤣\" }, b{ \"😅\" }; std::thread t{ [\u0026] {swap(a, b); } }; // 1 std::thread t2{ [\u0026] {swap(b, a); } }; // 2 1 执行的时候，先上锁 a 的互斥量，再上锁 b 的互斥量。 2 执行的时候，先上锁 b 的互斥量，再上锁 a 的互斥量。 完全可能线程 A 执行 1 的时候上锁了 a 的互斥量，线程 B 执行 2 上锁了 b 的互斥量。线程 A 往下执行需要上锁 b 的互斥量，线程 B 则要上锁 a 的互斥量执行完毕才能解锁，哪个都没办法往下执行，死锁。 如何解决？可以使用 C++ 标准库中的 std::lock，它能一次性锁住多个互斥量，并且没有死锁风险。修改后 swap 代码如下： void swap(X\u0026 lhs, X\u0026 rhs) { if (\u0026lhs == \u0026rhs) return; std::lock(lhs.m, rhs.m); // 给两个互斥量上锁 std::lock_guard\u003cstd::mutex\u003e lock1{ lhs.m,std::adopt_lock }; std::lock_guard\u003cstd::mutex\u003e lock2{ rhs.m,std::adopt_lock }; swap(lhs.object, rhs.object); } 因为前面已经使用了 std::lock 上锁，所以后面的 std::lock_guard 构造都额外传递了一个 std::adopt_lock 参数，让其选择到不上锁的构造函数。函数退出也能正常解锁。 std::lock 给 lhs.m 或 rhs.m 上锁时若抛出异常，则在重抛前对任何已锁的对象调用 unlock() 解锁，也就是 std::lock 要么将互斥量都上锁，要么一个都不锁。 C++17 新增了 std::scoped_lock ，提供此函数的 RAII 包装，通常它比裸调用 std::lock 更好。 所以我们前面的代码可以改写为： void swap(X\u0026 lhs, X\u0026 rhs) { if (\u0026lhs == \u0026rhs) return; std::scoped_lock guard{ lhs.m,rhs.m }; swap(lhs.object, rhs.object); } 使用 std::scoped_lock 可以将所有 std::lock 替换掉，减少错误发生。也可以用 std::unique_lock（可以简单理解为 std::lock_guard 的升级版，具有额外的功能，为更复杂的锁做准备），详情见标准库文档。 总结，避免死锁要注意： 避免嵌套锁：线程获取一个锁时，就别再获取第二个锁。每个线程只持有一个锁，自然不会产生死锁。如果必须要获取多个锁，使用 std::lock。 避免在持有锁时调用外部代码 使用固定顺序获取锁 ","date":"2025-03-23","objectID":"/2025/acc27a1/:5:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"读写锁 如果需要多线程读取写（多线程读不存在数据竞争；而写和读共存时存在竞争），使用 std::mutex 开销较大。这时可以用专门的读写锁，即 std::shared_timed_mutex (C++ 14)，std::shared_mutex (C++ 17)。示例代码： class Settings { private: std::map\u003cstd::string, std::string\u003e data_; mutable std::shared_mutex mutex_; // “M\u0026M 规则”：mutable 与 mutex 一起出现 public: void set(const std::string\u0026 key, const std::string\u0026 value) { std::lock_guard\u003cstd::shared_mutex\u003e lock{ mutex_ }; data_[key] = value; } std::string get(const std::string\u0026 key) const { std::shared_lock\u003cstd::shared_mutex\u003e lock(mutex_); auto it = data_.find(key); return (it != data_.end()) ? it-\u003esecond : \"\"; // 如果没有找到键返回空字符串 } }; ","date":"2025-03-23","objectID":"/2025/acc27a1/:6:0","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"使用互斥量实现并发读写锁（字节 Data AML 一面手撕题） 我们知道，写操作是独占的；而读操作是非独占的，即多个线程可以同时读。如果多线程访问某个共享变量时，每次访问时都加上一个互斥锁，这样开销会非常大。 所以我们期望在多个线程试图读取共享变量的时候，它们可以立刻获取因为读而加的锁，而不是需要等待前一个线程释放。当然，如果一个线程用写锁锁住了临界区，那么其他线程无论是读还是写都会发生阻塞。 #include \u003ciostream\u003e #include \u003cmutex\u003e #include \u003cthread\u003e class ReadWriteLock { private: std::mutex readMutex; // 用于保护读操作计数器的互斥量 std::mutex writeMutex; // 用于保护写操作的互斥量 int readCount = 0; // 记录当前正在进行读操作的线程数量 bool writing = false; // 表示当前是否有线程正在进行写操作 public: void readLock() { // 锁定读操作互斥量 std::unique_lock\u003cstd::mutex\u003e readLock(readMutex); // 增加读操作计数器 ++ readCount; // 等待没有写操作时进行读操作 while (writing) { readLock.unlock(); std::this_thread::yield(); // 让出CPU，避免忙等待 readLock.lock(); } } void readUnlock() { // 锁定读操作互斥量并减少读操作计数器 std::lock_guard\u003cstd::mutex\u003e readLock(readMutex); -- readCount; } void writeLock() { // 锁定写操作互斥量 std::unique_lock\u003cstd::mutex\u003e writeLock(writeMutex); // 等待没有读操作和写操作时进行写操作 while (readCount \u003e 0 || writing) { writeLock.unlock(); std::this_thread::yield(); // 让出CPU，避免忙等待 writeLock.lock(); } // 标记正在进行写操作 writing = true; } void writeUnlock() { // 锁定写操作互斥量并标记写操作完成 std::lock_guard\u003cstd::mutex\u003e writeLock(writeMutex); writing = false; } }; // 示例使用 int sharedData = 0; ReadWriteLock lock; void reader() { lock.readLock(); std::cout \u003c\u003c \"Reading: \" \u003c\u003c sharedData \u003c\u003c std::endl; lock.readUnlock(); } void writer() { lock.writeLock(); ++ sharedData; std::cout \u003c\u003c \"Writing: \" \u003c\u003c sharedData \u003c\u003c std::endl; lock.writeUnlock(); } int main() { std::thread readers[5]; std::thread writers[3]; // 创建多个读线程和写线程 for (int i = 0; i \u003c 5; ++i) { readers[i] = std::thread(reader); } for (int i = 0; i \u003c 3; ++i) { writers[i] = std::thread(writer); } // 等待所有线程执行完毕 for (auto\u0026 reader : readers) { reader.join(); } for (auto\u0026 writer : writers) { writer.join(); } return 0; } 这段代码中，锁定操作用的是 std::unique_lock，而解锁操作用的是 std::lock_guard。这两者都是 C++ 11 引入的 RAII 包装。正如上面所述，unique_lock 是 lock_guard 的升级版（更灵活，常与条件变量的 wait()、notify_one()、notify_all()配合使用），这里锁定时需要解锁和重新锁定互斥量。这对于需要在等待条件满足时解锁互斥量并让出 CPU 的场景非常有用。 ","date":"2025-03-23","objectID":"/2025/acc27a1/:6:1","tags":["C++"],"title":"并发编程（一）","uri":"/2025/acc27a1/"},{"categories":["八股"],"content":"介绍 C++ 中的内存分配、管理以及智能指针的原理及使用 ","date":"2025-03-23","objectID":"/2025/01dc872/:0:0","tags":["C++"],"title":"内存分配","uri":"/2025/01dc872/"},{"categories":["八股"],"content":"C++ 中内存的管理 ","date":"2025-03-23","objectID":"/2025/01dc872/:1:0","tags":["C++"],"title":"内存分配","uri":"/2025/01dc872/"},{"categories":["八股"],"content":"程序地址空间 C++ 中，内存分布分为五块区域，分别是：栈；堆；全局变量和静态变量（存放于 data 段和 bss 段）；常量；代码； 上图是内核和用户的虚拟地址空间分布情况，其中，局部变量和参数等都存放在栈中，这部分空间由系统进行管理；而堆中空间主要是用于用户调用 new或 malloc 时分配的空间。这部分区域由用户管理，因此容易造成内存泄漏。 malloc 底层实现原理 step1：从内存池中分配。若所需要内存 \u003c 128KB，则从内存池中尝试分配。若无，则进行 brk 系统调用，从堆上申请内存。 step2：若 \u003e 128KB，不看内存池，直接使用 mmap 系统调用，从文件映射区（同时还存放动态库）中获得内存。 new new 是一个操作符，能够触发析构函数的调用，并且在申请空间的时候也可以完成初始化。搭配 delete 使用 这里我觉得这种虚拟地址空间划分方式粒度太粗，不足以说明具体情况 ","date":"2025-03-23","objectID":"/2025/01dc872/:1:1","tags":["C++"],"title":"内存分配","uri":"/2025/01dc872/"},{"categories":["八股"],"content":"智能指针 智能指针分为三类：shared_ptr，unique_ptr，weak_ptr（c98还引入了 auto_ptr，但已在 c++11中被废弃） unique_ptr unique_ptr 表示专属所有权，用 unique_ptr 管理的内存，只能被一个对象持有。故不支持复制和赋值。 auto w = std::make_unique\u003cWidget\u003e(); // 在 c++14 中，可以用 make_unique 方法来构造。 auto w2 = w; // 编译错误 因此只能通过移动来更改专属所有权： auto w = std::make_unique\u003cWidget\u003e(); auto w2 = std::move(w); // w2 获得内存所有权，w 此时等于 nullptr 用法：需要引入头文件 \u003cmemory\u003e，可以使用右值拷贝构造或 make 方法来构造指针。 unique_ptr\u003cint\u003e p1 = make_unique\u003cint\u003e(100); unique_ptr\u003cstring\u003e ps1(new string(\"good luck\")); 适用场景 忘记 delete class Box { public: Box() : w(new Widget()) {} ~Box() { // 析构函数中忘记 delete w } private: Widget* w; }; 异常安全 void process() { Widget* w = new Widget(); w-\u003edo_something(); // 如果发生异常，那么 delete w 将不会执行，此时就会发生内存泄露 delete w; // 也可以用 try...catch 块捕捉异常，并在 catch 语句中 delete，但是不太美观 + 容易漏写 } shared_ptr shared_ptr 代表的是共享所有权，即多个 shared_ptr 可以共享同一块内存。shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr，引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1。当引用计数为 0 的时候，则 delete 内存。 auto w = std::make_shared\u003cWidget\u003e(); auto w2 = w; cout \u003c\u003c w.use_count() \u003c\u003c endl; // g++ -std=c++11 main main.cc output-\u003e2 同时，shared_ptr 也支持移动。从语义上来看，移动指的是所有权的传递。如下： auto w = std::make_shared\u003cWidget\u003e(); auto w2 = std::move(w); // 此时 w 等于 nullptr，w2.use_count() 等于 1 注意 shared_ptr 性能开销更大，几乎是 unique_ptr 的两倍（因为还要维护一个计数） 考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢 使用移动优化性能，尽量使用 std::move 来将 shared_ptr 转移给新对象。因为移动不用增加引用计数，性能更好 使用场景：通常用于指定，有可能多个对象同时管理一个内存的时候。 weak_ptr weak_ptr 是为了解决 shared_ptr 双向引用的问题。即： class B; struct A { shared_ptr\u003cB\u003e b; }; struct B { shared_ptr\u003cA\u003e a; }; auto pa = make_shared\u003cA\u003e(); auto pb = make_shared\u003cB\u003e(); pa-\u003eb = pb; pb-\u003ea = pa; pa 和 pb 存在着循环引用，根据 shared_ptr 引用计数的原理，pa 和 pb 都无法被正常的释放。 对于这种情况, 我们可以使用 weak_ptr： class B; struct A { shared_ptr\u003cB\u003e b; }; struct B { weak_ptr\u003cA\u003e a; }; auto pa = make_shared\u003cA\u003e(); auto pb = make_shared\u003cB\u003e(); pa-\u003eb = pb; pb-\u003ea = pa; weak_ptr 不会增加引用计数，因此可以打破 shared_ptr 的循环引用。 通常做法是 parent 类持有 child 的 shared_ptr, child 持有指向 parent 的 weak_ptr。这样也更符合语义。 ","date":"2025-03-23","objectID":"/2025/01dc872/:1:2","tags":["C++"],"title":"内存分配","uri":"/2025/01dc872/"},{"categories":["八股"],"content":"实现过程 鉴于看到面经中有同学被问到过智能指针的底层实现，因此这里给出两种智能指针（weak_ptr略）的简单实现方式。 Tips this 本身是一个指针，指向该类实例化后的对象本身；*this表示解引用，C++中对一个指针进行解引用，得到的是当前对象的引用，也就是对象本身 注意这里 (*this-\u003e_count) ++ 的用法 注意这里 = delete 的语法，用于显示地禁用特定的函数 shared_ptr： template\u003ctypename T\u003e class shared_ptr { private: T* _ptr; int* _count; // 引用计数 public: // 构造函数 shared_ptr(T* ptr = nullptr) : _ptr(ptr) { if (_ptr) _count = new int(1); else _count = new int(10); } // 拷贝构造 shared_ptr(const shared_ptr\u0026 ptr) { if (this != ptr) { this-\u003e_ptr = ptr._ptr; this-\u003e_count = ptr._count; (*this-\u003e_count) ++ ; } } // 重载operator= shared_ptr\u0026 operator=(const shared_ptr \u0026 ptr) { if (this-\u003e_ptr == ptr._ptr) { return *this; } if (this-\u003e_ptr) { (*this-\u003e_count) -- ; if (*this-\u003e_count == 0) { delete this-\u003e_ptr; delete this-\u003e_count; } } this-\u003e_ptr = ptr._ptr; this-\u003e_count = ptr._count; (*this-\u003e_count) ++ ; return *this; } // operator*重载 T\u0026 operator*() { if (this-\u003e_ptr) { return *(this-\u003e_ptr); } } // operator-\u003e重载 T* operator-\u003e() { if (this-\u003e_ptr) { return this-\u003e_ptr; } } // 析构函数 ~shared_ptr() { (*this-\u003e_count) -- ; if (*this-\u003e_count == 0) { delete this-\u003e_ptr; delete this-\u003e_count; } } // 返回引用计数 int use_count() { return *this-\u003e_count; } }; unique_ptr： template\u003ctypename T\u003e class unique_ptr { private: T* _ptr; public: // 构造函数 unique_ptr(T* ptr = nullptr) : _ptr(ptr) {} // 析构函数 ~unique_ptr() { del() }; // 先释放资源（如果持有），再持有资源 void reset(T* ptr) { del(); _ptr = ptr; } // 返回资源，资源的释放由调用方处理 T* release() { T* ptr = _ptr; _ptr = nullptr; return ptr; } // 获取资源，调用方应该只使用不释放，否则会两次delete资源 T* get() { return _ptr; } private: // 释放 void del() { if (_ptr == nullptr) return; delete _ptr; _ptr = nullptr; } // 禁用拷贝构造 unique_ptr(const unique_ptr \u0026) = delete; // 禁用拷贝赋值 unique_ptr\u0026 operator = (const unique_ptr \u0026) = delete; }; ","date":"2025-03-23","objectID":"/2025/01dc872/:1:3","tags":["C++"],"title":"内存分配","uri":"/2025/01dc872/"},{"categories":["八股"],"content":"C++多态的实现方法及原理 ","date":"2025-03-23","objectID":"/2025/b97727d/:0:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"虚函数 https://zhuanlan.zhihu.com/p/54145222 https://zhuanlan.zhihu.com/p/629281871 ","date":"2025-03-23","objectID":"/2025/b97727d/:1:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"概念解释 用一个例子理解虚函数的作用： Animal* catAnimal = \u0026cat Animal\u0026 dogAnimal = dog; catAnimal-\u003espeak() dogAnimal.speak() // 调用的还是基类 Animal 本身的方法 // 为什么要用基类指针或引用来完成？基类能够动态确定其实际所指向的派生类对象，并调用合适版本的方法， // 那么一个函数就可以解决上面的问题 // 用虚函数来完成上述功能 class Animal { public: // ... // virtual string speak() const { return \"???\"; } } class Cat { public: // ... // virtual string speak() const { return \"Meow\"; } } class Dog { public: // ... // virtual string speak() const { return \"Woof\"; } } Animal 类被 Cat 和 Dog类继承并覆盖了 speak 函数以实现不同的行为。当使用 Animal的指针或引用来调用 speak 函数时，会根据运行时的对象类型来动态地决定调用哪个子类的函数，从而实现多态性。 ","date":"2025-03-23","objectID":"/2025/b97727d/:1:1","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"实现原理 C++ 中，虚函数的实现原理基于两个概念：虚函数表和虚函数指针。 虚函数表 每个包含虚函数的类，都会生成一个虚函数表（Virtual Table），存储着该类中所有的虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。 虚函数指针 在对象内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针（Virtual Table Pointer，a.k.a VTable指针）。这个指针指向该对象对应的虚函数表，从而让程序能够动态地调用正确的虚函数。 虚函数指针可以类比操作系统中，虚拟内存映射中的页表基址，存储在页表基址寄存器（xv6 是 satp 寄存器）中，有了页表基址，就可以找到一级页表，从而找到二级页表，进而找到物理地址。 当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。但同时由于虚函数表的存在，导致需要额外的存储空间来存储虚函数表及其指针，导致 C++ 在调用虚函数时比其他语言成本要高。 虚函数指针是实现多级继承的关键，在多级继承中，每个子类都需要维护自己的虚函数表及其虚函数指针 虚函数的调用过程 在编译期间，编译器会根据函数调用的类型和对象的类型确定要调用的函数。 在运行期间，程序会根据对象的实际类型来决定调用哪个函数。这个过程叫做动态绑定或者后期绑定。 程序通过虚函数表（vtable）来实现动态绑定。每个含有虚函数的类都有自己的虚函数表，存储了指向实际函数地址的指针。在对象被创建时，它的指针会指向所属类的虚函数表。 当调用虚函数时，在对象中存储的指针会被解引用，获取到虚函数表的地址。然后根据函数调用的类型，从虚函数表中获取相应的函数地址。 最后，程序跳转到函数地址处执行实际的代码。由于是动态绑定，所以调用的函数是根据对象实际类型来决定的。 ","date":"2025-03-23","objectID":"/2025/b97727d/:1:2","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"虚函数的使用 在 C++ 中，派生类可以重写 (override) 它继承的虚函数，这被称为函数的覆盖 (overriding)。当然，子类也可以选择不重写基类的虚函数，那么它将默认继承基类的实现，这就是虚函数的重载 (overloading)。 class Base { public: virtual void foo() { std::cout \u003c\u003c \"Base::foo()\" \u003c\u003c std::endl; } }; class Derived : public Base { public: void foo() { std::cout \u003c\u003c \"Derived::foo()\" \u003c\u003c std::endl; } }; int main() { Derived obj; Base* ptr = \u0026obj; ptr-\u003efoo(); // 输出：Derived::foo() return 0; } 可以看到，不论是基类版本还是派生类版本，我们都在函数前面使用了 virtual 关键字，事实上，派生类中的 virtual 关键字并不是必要的。一旦基类中的方法打上了 virtual 标签，那么派生类中匹配的函数也是虚函数。但是，还是建议在后面的派生类中加上 virtual 关键字，作为虚函数的一种提醒，以便后面可能还会有更远的派生。 子类中重写虚函数时，访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错； 虚函数的覆盖实际上是通过指定 override 关键字显示声明来实现的。例如： class Base { public: virtual void foo() { std::cout \u003c\u003c \"Base::foo()\" \u003c\u003c std::endl; } }; class Derived : public Base { public: void foo() override { std::cout \u003c\u003c \"Derived::foo()\" \u003c\u003c std::endl; } }; int main() { Derived obj; Base* ptr = \u0026obj; ptr-\u003efoo(); // 输出：Derived::foo() return 0; } 进一步地，一般来说派生类需要重写基类的方法，以便于用基类指针动态调用不同派生类的成员方法，但是一旦函数签名不同，就会导致重写失败。为了避免可能发生的小错误导致重写失败无法调用派生类的成员方法，需要在派生类的成员方法后添加 override： class Super { public: virtual string getName1(int x) { return \"Super\"; } virtual string getName2(int x) { return \"Super\"; } }; class Sub: public Super{ public: virtual string getName1(double x) override { return \"Sub\"; } virtual string getName2(int x) const override { return \"Sub\"; }// 此时无法编译 }; ","date":"2025-03-23","objectID":"/2025/b97727d/:1:3","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"纯虚函数 纯虚函数是指在基类中定义的，没有实现的虚函数。这里的 “=0” 表示该函数为虚函数。 virtual void func() = 0; 纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类的对象（即该类为抽象类）。 抽象类是包含纯虚函数的类，它们不能被实例化，只能被继承。 抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。 示例代码： class Shape{ public: // 纯虚函数 virtual double getArea() = 0; }; // 继承自抽象类Shape class Rectangle: public Shape { public: double width; double height; double getArea() {return width * height;} }; // 继承自抽象类Shape class Circle: public Shape { public: double radius; double getArea() {return 3.14*radius*radius;} }; ","date":"2025-03-23","objectID":"/2025/b97727d/:2:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"动态绑定与静态绑定 通过以上描述，我们可以得知虚函数可以用来进行动态绑定（区分于静态绑定）。 // 静态绑定示例 class Shape { public: void draw() { cout \u003c\u003c \"Drawing a shape.\" \u003c\u003c endl; } }; class Circle : public Shape { public: void draw() { cout \u003c\u003c \"Drawing a circle.\" \u003c\u003c endl; } }; int main() { Shape* shapeObj = new Circle(); shapeObj-\u003edraw(); // 编译时期确定方法调用，输出 \"Drawing a shape.\" } // 动态绑定示例 class Shape { public: virtual void draw() { cout \u003c\u003c \"Drawing a shape.\" \u003c\u003c endl; } }; class Circle : public Shape { public: void draw() { cout \u003c\u003c \"Drawing a circle.\" \u003c\u003c endl; } }; int main() { Shape* shapeObj = new Circle(); shapeObj-\u003edraw(); // 运行时期确定方法调用，输出 \"Drawing a circle.\" } ","date":"2025-03-23","objectID":"/2025/b97727d/:3:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"静态多态与动态多态 静态多态（也称为编译时多态）是指在编译时就能够确定函数或方法的调用对象，即函数或方法的重载。在静态多态中，函数或方法的重载是通过参数类型、参数数量或参数顺序来区分的。 int add(int a, int b){ return a + b; } double add(double a, double b){ return a + b; } 当调用 add() 方法时，编译器会根据传递给方法的参数类型来决定使用哪个重载版本。 动态多态（也称为运行时多态）是指在程序运行时才能确定函数或方法的调用对象，即虚函数或抽象类。在动态多态中，函数或方法的重载是通过继承和多态来实现的。见上面的虚函数代码样例。 ","date":"2025-03-23","objectID":"/2025/b97727d/:4:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"一些常见问题 ","date":"2025-03-23","objectID":"/2025/b97727d/:5:0","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"虚析构函数 我们知道析构函数存在的必要性之一就是，如果类内有指针类型变量，需要在析构函数中进行手动释放（delete ptr）。但是如果用基类指针指向子类对象，当子类实例被删除时，只会调用基类的析构函数，而不会调用子类的析构函数，从而使得子类中动态分配的内存无法被释放造成内存泄漏。这个时候需要使用虚析构函数来释放内存。 ","date":"2025-03-23","objectID":"/2025/b97727d/:5:1","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"虚函数的性能影响 根据上面所述，使用虚函数能够达到动态绑定的目的，这同时会增加一些开销，降低执行效率。但是现代编译器能够将开销优化至可以忽略不计。 ","date":"2025-03-23","objectID":"/2025/b97727d/:5:2","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["八股"],"content":"多重继承中的虚函数 class Base1 { public: virtual void func() { cout \u003c\u003c \"Base1::func()\" \u003c\u003c endl; } }; class Base2 { public: virtual void func() { cout \u003c\u003c \"Base2::func()\" \u003c\u003c endl; } }; class Derived : public Base1, public Base2 { public: virtual void func() { Base1::func(); Base2::func(); } }; 一个类同时继承多个基类，并且这些基类中有多个同名虚函数，那么子类中必须对这些虚函数进行重写。 我理解是，如果是单继承，那么可以重写也可以不重写，不重写相当于就是继承基类的实现；而多继承中为了避免未知的错误，必须对每个基类虚函数进行重写。 ","date":"2025-03-23","objectID":"/2025/b97727d/:5:3","tags":["C++"],"title":"虚函数与多态","uri":"/2025/b97727d/"},{"categories":["算法"],"content":"由 randA() 实现 randB()：万能构造法 randA() 构造 randB() 时，需要找一个最大质因子不超过 A 的数 n (n\u003e=B），然后对 n 分解质因子就能找到每个采样需要取多少种结果。实际到具体数字时，可以把部分质因子合并成不超过 A 的数，从而减少采样次数。 举个具体例子，如何用 rand7() 来构造 rand10() ","date":"2025-03-22","objectID":"/2025/b44918a/:0:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["算法"],"content":"确定采样参数 步骤 1：选择一个合适的数 n 我们选择 n = 30，因为它大于或等于 10，并且它的最大质因子是 5，不超过 7。 步骤 2：对 n 进行质因子分解 将 30 分解为质因子的乘积形式： $$ 30 = 21 \\times 31 \\times 5^1 $$ 步骤 3：确定采样次数和结果数量 根据质因子分解的结果，我们需要进行 3 次采样，每次采样的结果数量分别为 2、3 和 5。（分别对应三个质因子） ","date":"2025-03-22","objectID":"/2025/b44918a/:1:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["算法"],"content":"进行采样 我们将进行 3 次采样，每次采样使用 rand7() 函数来生成一个介于 1 和 7 之间的随机数。 第一次采样 使用 rand7() 来生成一个随机数，如果结果在 [1, 2] 范围内，则将其作为第一次采样的结果。否则，重新采样。 int first; while (true) { first = rand7(); if (first \u003c= 2) break; } 第二次采样 使用 rand7() 来生成一个随机数，如果结果在 [1, 3] 范围内，则将其作为第一次采样的结果。否则，重新采样。 int second; while (true) { second = rand7(); if (second \u003c= 3) break; } 第三次采样 使用 rand7() 来生成一个随机数，如果结果在 [1, 5] 范围内，则将其作为第一次采样的结果。否则，重新采样。 int third; while (true) { third = rand7(); if (third \u003c= 5) break; } ","date":"2025-03-22","objectID":"/2025/b44918a/:2:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["算法"],"content":"组合结果 将每次采样的结果组合起来，得到一个长度为 30 的序列。具体来说： first 的取值范围是 [1, 2]，总共有 2 种可能。 second 的取值范围是 [1, 3]，总共有 3 种可能。 third 的取值范围是 [1, 5]，总共有 5 种可能。 我们通过三次采样得到三个值：first、second 和 third。我们的目标是将这三个值组合成一个唯一的索引，这个索引应该对应于一个长度为 30 的序列中的一个位置。 这三个值的所有可能组合数是：$ 2\\times 3\\times 5 = 30 $， 这正好等于我们预定义的序列长度。 ","date":"2025-03-22","objectID":"/2025/b44918a/:3:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["算法"],"content":"映射 为了将这三个值组合成一个唯一的索引，我们需要为每个值分配一个权重，使得它们的组合能够覆盖从 1 到 30 的所有整数。 公式为： $$ index = (first - 1)\\times 3 \\times 5 + (second - 1)\\times 5 + (third - 1) + 1 $$ 代表： $$[0, 1]\\times 3\\times 5 \\rightarrow [0, 15]$$ $$[0, 2]\\times 5 \\rightarrow [0, 10]$$ $$[0, 4] + 1 \\rightarrow [1, 5]$$ ","date":"2025-03-22","objectID":"/2025/b44918a/:4:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["算法"],"content":"完整代码 int rand10() { int first, second, third; while (true) { first = rand7(); // 第一次采样 if (first \u003c= 2) break; // 如果结果在 [1, 2] 范围内，则退出循环 } while (true) { second = rand7(); // 第二次采样 if (second \u003c= 3) break; // 如果结果在 [1, 3] 范围内，则退出循环 } while (true) { third = rand7(); // 第三次采样 if (third \u003c= 5) break; // 如果结果在 [1, 5] 范围内，则退出循环 } // 将结果组合并映射到 [1, 10] 范围内 int index = (first - 1) * 3 * 5 + (second - 1) * 5 + (third - 1) + 1; if (index \u003c= 10) return index; else return rand10(); // 如果结果超出范围，则重新采样 } ","date":"2025-03-22","objectID":"/2025/b44918a/:5:0","tags":["构造"],"title":"构造 RandX()","uri":"/2025/b44918a/"},{"categories":["随记"],"content":"建站踩坑过程 ","date":"2025-03-22","objectID":"/2025/b487c0a/:0:0","tags":null,"title":"建站踩坑记录","uri":"/2025/b487c0a/"},{"categories":["随记"],"content":"集成 latex 方法一 ","date":"2025-03-22","objectID":"/2025/b487c0a/:1:0","tags":null,"title":"建站踩坑记录","uri":"/2025/b487c0a/"},{"categories":["随记"],"content":"优秀参考 https://github.com/shuzang/shuzang.github.io ","date":"2025-03-22","objectID":"/2025/b487c0a/:2:0","tags":null,"title":"建站踩坑记录","uri":"/2025/b487c0a/"},{"categories":["随记"],"content":"content 目录位置 移动到左边：https://blog.csdn.net/Xuyiming564445/article/details/122011603 ","date":"2025-03-22","objectID":"/2025/b487c0a/:3:0","tags":null,"title":"建站踩坑记录","uri":"/2025/b487c0a/"},{"categories":["随记"],"content":"评论系统 使用 giscus，将 repo 的discussion 模块用于评论。详情见： http://www.icharm.me/hugo-loveit-using/index.zh_cn.html https://giscus.app/zh-CN ","date":"2025-03-22","objectID":"/2025/b487c0a/:4:0","tags":null,"title":"建站踩坑记录","uri":"/2025/b487c0a/"},{"categories":null,"content":"关于我 MLSys 入门小菜鸡 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"}]