---
title: å¹¶å‘ç¼–ç¨‹ï¼ˆä¸€ï¼‰
subtitle:
date: 2025-03-23T16:32:43+08:00
slug: acc27a1
draft: false
tags: [C++]
categories: [å…«è‚¡]
author:
  name: "yitao" # æ–‡ç« ä½œè€…
---

[ã€Šç°ä»£C++å¹¶å‘ç¼–ç¨‹æ•™ç¨‹ã€‹](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/) â€”â€” C++å¹¶å‘ç¼–ç¨‹å­¦ä¹ ç¬”è®°ï¼ˆä¸€ï¼‰

<!--more-->

## å¯åŠ¨çº¿ç¨‹

```cpp
#include <iostream>
#include <thread>

void hello() {
    printf("hello world!\n");
}

int main() {
    std::thread my_thread(hello);

}
```

å¯ä»¥ä¼ å…¥å‡½æ•°å¯¹è±¡ï¼Œå¦‚ä¸Šä¾‹æ‰€ç¤ºã€‚ä¹Ÿå¯ä»¥ä¼ å…¥ç±»æˆ–è€…å…¶ä»–é‡è½½äº† `()` ï¼ˆcallableï¼‰è¿ç®—ç¬¦çš„å¯¹è±¡ï¼Œä¾‹å¦‚ï¼š

```cpp
class task {
public:
    void operator()() const {
        do_something();
        do_something_else();
    }
};

task f;
std::thread my_thread(f);
```

ä½†è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸ªé—®é¢˜ï¼Œç”±äº C++ çš„è¯­æ³•é—®é¢˜ï¼Œæœ‰æ—¶ä¼šé€ æˆæ­§ä¹‰ï¼Œä¾‹å¦‚ï¼š

```cpp
std::thread my_thread(task());  // è¿™ä¼šè¢«è®¤ä¸ºæ˜¯å£°æ˜äº†ä¸€ä¸ªè¿”å›å€¼ä¸º thread çš„ï¼Œåä¸º my_thread çš„å‡½æ•°
```

è¿™é‡Œæœ€å¥½ä½¿ç”¨ `{}` è¿ç®—ç¬¦æ¥åˆ›å»ºä¸€ä¸ª `thread` å¯¹è±¡ï¼Œå¦‚ï¼š `std::thread my_thread{task()}`ã€‚åŒæ—¶ä¹Ÿå¯ä»¥ç”¨åŒ¿åå‡½æ•°ï¼ˆlambdaè¡¨è¾¾å¼ï¼‰æ¥åˆ›å»ºçº¿ç¨‹ï¼š

```cpp
#include <iostream>
#include <thread>

int main() {
    std::thread thread{ [] {std::cout << "Hello World!\n"; } };
    thread.join();
}
```

> [!NOTE] å½“ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡åˆ›å»ºæ—¶ï¼ˆå³ `std::thread` å¯¹è±¡æ„é€ æ—¶ï¼‰å°±å¼€å§‹æ‰§è¡Œä¼ å…¥çš„å‡½æ•° `f` äº†ã€‚

## çº¿ç¨‹ç®¡ç†

å¯åŠ¨çº¿ç¨‹åï¼ˆæ„é€  `std::thread` å¯¹è±¡ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨çº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸç»“æŸä¹‹å‰ï¼Œå³  `std::thread::~thread` è°ƒç”¨ä¹‹å‰ï¼Œå†³å®šå®ƒçš„æ‰§è¡Œç­–ç•¥ï¼ŒåŒ…æ‹¬ `join()` å’Œ `detach()`ã€‚

### `join()`

å…¶ä¸­ `join()` è¡¨ç¤ºå°†é˜»å¡å…³è”çš„çº¿ç¨‹ï¼Œç›´è‡³æ‰§è¡Œå®Œæ¯•ã€‚å†…éƒ¨å®ç°ä¼šè®© `std::thread::joinable()` è¿”å› `false`ã€‚å¦åˆ™ä¼šè¿”å› `true`ï¼Œæ‰§è¡Œ `std::terminate()`ã€‚

### `detach()`

æ‰§è¡Œäº† `detach()` åï¼Œè¡¨ç¤ºçº¿ç¨‹å¯¹è±¡æ”¾å¼ƒäº†å¯¹çº¿ç¨‹èµ„æºçš„æ‰€æœ‰æƒï¼Œå…è®¸æ­¤çº¿ç¨‹çš„ç‹¬ç«‹è¿è¡Œï¼Œåœ¨çº¿ç¨‹é€€å‡ºæ—¶é‡Šæ”¾æ‰€æœ‰åˆ†é…çš„èµ„æºã€‚é€šå¸¸ä¸å»ºè®®ä½¿ç”¨ `detach()`ï¼Œå¯ä»¥ç”¨ `join()` æ›¿ä»£ã€‚

å¯ä»¥æä¾›ä¸€ä¸ªç±»ï¼ŒRAIIï¼ˆResource Acquisition Initilizationï¼‰åœ°ç¡®ä¿çº¿ç¨‹æ‰§è¡Œå®Œæˆï¼Œçº¿ç¨‹å¯¹è±¡æ­£å¸¸ææ„é‡Šæ”¾èµ„æºï¼š

```cpp
class thread_guard {
    std::thread& m_t;
public:
    explicit thread_guard(std::thread& t) : m_t{ t } {}
    ~thread_guard() {
        std::puts("ææ„");     // æ‰“å°æ—¥å¿— ä¸ç”¨åœ¨ä¹
        if (m_t.joinable()) { // çº¿ç¨‹å¯¹è±¡å½“å‰å…³è”äº†æ´»è·ƒçº¿ç¨‹
            m_t.join();
        }
    }
    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};
void f() {
    int n = 0;
    std::thread t{ func{n},10 };
    thread_guard g(t);
    f2(); // å¯èƒ½æŠ›å‡ºå¼‚å¸¸
}
```

## ä¼ é€’å‚æ•°

å‘å¯è°ƒç”¨å¯¹è±¡ä¼ é€’å‚æ•°ï¼Œåªéœ€è¦å°†è¿™äº›å‚æ•°ä½œä¸º `std::thread` çš„æ„é€ å‚æ•°å³å¯ã€‚
> [!NOTE] éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™äº›å‚æ•°ä¼šå¤åˆ¶åˆ°æ–°çº¿ç¨‹çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå³ä½¿å‡½æ•°ä¸­çš„å‚æ•°æ˜¯å¼•ç”¨ï¼Œä¾ç„¶å®é™…æ˜¯å¤åˆ¶ã€‚

```cpp
void f(int, const int& a);

int n = 1;
std::thread t{ f, 3, n };
```

çº¿ç¨‹å¯¹è±¡ t çš„æ„é€ æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯è¿™ä¸ª n å®é™…ä¸Šå¹¶æ²¡æœ‰æŒ‰å¼•ç”¨ä¼ é€’ï¼Œè€Œæ˜¯æŒ‰å€¼å¤åˆ¶çš„ã€‚å¦‚æœæˆ‘ä»¬çš„ f çš„å½¢å‚ç±»å‹ä¸æ˜¯ const çš„å¼•ç”¨ï¼Œåˆ™ä¼šäº§ç”Ÿä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚å¯ä»¥ç”¨æ ‡å‡†åº“çš„ `std::ref`ã€`std::cref` å‡½æ•°æ¨¡ç‰ˆã€‚

```cpp
void f(int, int& a) {
    std::cout << &a << '\n';
}

int main() {
    int n = 1;
    std::cout << &n << '\n';
    std::thread t { f, 3, std::ref(n) };
    t.join();
}
```

## å…±äº«æ•°æ®

æˆ‘ä»¬éƒ½çŸ¥é“çº¿ç¨‹é€šä¿¡çš„æ–¹å¼æœ‰==ä¸´ç•ŒåŒºã€äº’æ–¥é‡ã€ä¿¡å·é‡ã€æ¡ä»¶å˜é‡ã€è¯»å†™é”==ï¼š

> 1. ä¸´ç•ŒåŒºï¼šæ¯ä¸ªçº¿ç¨‹ä¸­è®¿é—®ä¸´ç•Œèµ„æºçš„é‚£æ®µä»£ç ç§°ä¸ºä¸´ç•ŒåŒºï¼ˆCritical Sectionï¼‰ï¼ˆä¸´ç•Œèµ„æºæ˜¯ä¸€æ¬¡ä»…å…è®¸ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨çš„å…±äº«èµ„æºï¼‰ã€‚æ¯æ¬¡åªå‡†è®¸ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºï¼Œè¿›å…¥åä¸å…è®¸å…¶ä»–çº¿ç¨‹è¿›å…¥ã€‚ä¸è®ºæ˜¯ç¡¬ä»¶ä¸´ç•Œèµ„æºï¼Œè¿˜æ˜¯è½¯ä»¶ä¸´ç•Œèµ„æºï¼Œå¤šä¸ªçº¿ç¨‹å¿…é¡»äº’æ–¥åœ°å¯¹å®ƒè¿›è¡Œè®¿é—®ã€‚åœ¨ä¸´ç•ŒåŒºä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦è®²çš„äº’æ–¥é‡ï¼ˆMutexï¼‰
> 2. äº’æ–¥é‡ï¼šé‡‡ç”¨äº’æ–¥å¯¹è±¡æœºåˆ¶ï¼Œåªæœ‰æ‹¥æœ‰äº’æ–¥å¯¹è±¡çš„çº¿ç¨‹æ‰å¯ä»¥è®¿é—®ã€‚å› ä¸ºäº’æ–¥å¯¹è±¡åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥å¯ä»¥ä¿è¯å…¬å…±èµ„æºä¸ä¼šè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®ã€‚
> 3. ä¿¡å·é‡ï¼šè®¡æ•°å™¨ï¼Œå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€ä¸ªèµ„æºã€‚
> 4. æ¡ä»¶å˜é‡ï¼šé€šè¿‡æ¡ä»¶å˜é‡é€šçŸ¥æ“ä½œçš„æ–¹å¼æ¥ä¿æŒå¤šçº¿ç¨‹åŒæ­¥ã€‚
> 5. è¯»å†™é”ï¼šè¯»å†™é”ä¸äº’æ–¥é‡ç±»ä¼¼ã€‚ä½†äº’æ–¥é‡è¦ä¹ˆæ˜¯é”ä½çŠ¶æ€ï¼Œè¦ä¹ˆå°±æ˜¯ä¸åŠ é”çŠ¶æ€ã€‚è¯»å†™é”ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹å†™ï¼Œä½†å…è®¸ä¸€æ¬¡å¤šä¸ªçº¿ç¨‹è¯»ï¼Œè¿™æ ·æ•ˆç‡å°±æ¯”äº’æ–¥é”è¦é«˜ã€‚

å¦‚æœæœ‰ä»¥ä¸‹æƒ…å†µï¼Œå‡ºç°==æ•°æ®ç«äº‰==æƒ…å†µã€‚

```cpp
std::vector<int> v;

void f() { v.emplace_back(1); }
void f2() { v.erase(v.begin()); }

int main() {
    std::thread t{ f };
    std::thread t2{ f2 };
    t.join();
    t2.join();
    std::cout << v.size() << '\n';  // æœ‰æ—¶å‡ºç°æ®µé”™è¯¯ï¼Œæœ‰æ—¶è¾“å‡º0ï¼Œä¸ç¨³å®šçš„è¾“å‡ºç»“æœ
}
```

è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç”¨==äº’æ–¥é‡==æ¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚

```cpp
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>

std::mutex m;
std::vector<int> v;

void f() {
    m.lock();
    v.emplace_back(1);
    m.unlock();
}

void f2() {
    m.lock();
    v.erase(v.begin());
    m.unlock();
}

int main() {
    std::thread t{ f };
    std::thread t2{ f2 };
    t.join();
    t2.join();
    std::cout << v.size() << '\n';  // ç¨³å®šè¾“å‡º0
}
```

å¦å¤–ä¸€ä¸ªä¾‹å­ï¼Œä½¿ç”¨ mutex äº’æ–¥é‡å‰ï¼š

```cpp
void f() {
    // this_thread::get_id() è¡¨ç¤ºè·å–å½“å‰çº¿ç¨‹çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œä»¥ä¾¿åœ¨å¤šçº¿ç¨‹ç¨‹åºä¸­åŒºåˆ†ä¸åŒçš„çº¿ç¨‹ã€‚
    std::cout << std::this_thread::get_id() << '\n';  
}

int main() {
    std::vector<std::thread> threads;
    for (std::size_t i = 0; i < 10; ++i)
        threads.emplace_back(f);

    for (auto& thread : threads)
        thread.join();
}
```

> [!NOTE] è¿™é‡Œæœ‰ä¸€ä¸ªç‚¹ï¼Œæ­£å¥½è¯´æ˜ä¸€ä¸‹ `push_back()` å’Œ `emplace_back()` çš„åŒºåˆ«
> 1. å¦‚æœè¦ç”¨ `push_back`ï¼Œåˆ™éœ€è¦å…ˆæ„é€ ä¸€ä¸ª thread ä¸´æ—¶å¯¹è±¡ï¼š`threads.push_back(std::thread(f));`
> 2. è€Œå¦‚æœç”¨ `emplace_back`ï¼Œè¯¥æ–¹æ³•å…è®¸åœ¨ `vector` æœ«å°¾ç›´æ¥æ„é€ å¯¹è±¡ï¼Œè€Œæ— éœ€åˆ›å»ºä¸´æ—¶å¯¹è±¡ã€‚å®ƒæ¥å—æ„é€ å‡½æ•°çš„å‚æ•°ï¼Œå¹¶åœ¨é€‚å½“çš„ä½ç½®ç›´æ¥è°ƒç”¨æ„é€ å‡½æ•°ã€‚è¿™æ ·å¯ä»¥å‡å°‘ä¸å¿…è¦çš„å¯¹è±¡åˆ›å»ºå’Œç§»åŠ¨æ“ä½œï¼Œæé«˜æ€§èƒ½ï¼š`threads.emplace_back(f);`

ä½¿ç”¨åï¼š

```cpp
#include <mutex> // å¿…è¦æ ‡å¤´
std::mutex m;

void f() {
    m.lock();
    std::cout << std::this_thread::get_id() << '\n';
    m.unlock();
}

int main() {
    std::vector<std::thread>threads;
    for (std::size_t i = 0; i < 10; ++i)
        threads.emplace_back(f);

    for (auto& thread : threads)
        thread.join();
}
```

å½“å¤šä¸ªçº¿ç¨‹æ‰§è¡Œå‡½æ•° `f` çš„æ—¶å€™ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æˆåŠŸè°ƒç”¨ `lock()` ç»™äº’æ–¥é‡ä¸Šé”ï¼Œå…¶ä»–æ‰€æœ‰çš„çº¿ç¨‹ `lock()` çš„è°ƒç”¨å°†é˜»å¡æ‰§è¡Œï¼Œç›´è‡³è·å¾—é”ã€‚ç¬¬ä¸€ä¸ªè°ƒç”¨ `lock()` çš„çº¿ç¨‹å¾—ä»¥ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œæ‰§è¡Œæˆ‘ä»¬çš„ `std::cout` è¾“å‡ºè¯­å¥ï¼Œä¸ä¼šæœ‰ä»»ä½•å…¶ä»–çš„çº¿ç¨‹æ‰“æ–­è¿™ä¸ªæ“ä½œã€‚ç›´åˆ°çº¿ç¨‹æ‰§è¡Œ `unlock()`ï¼Œå°±è§£é”äº†äº’æ–¥é‡ã€‚é‚£ä¹ˆå…¶ä»–çº¿ç¨‹æ­¤æ—¶ä¹Ÿå°±èƒ½å†æœ‰ä¸€ä¸ªæˆåŠŸè°ƒç”¨ lockã€‚è‡³äºæ˜¯å“ªä¸ªçº¿ç¨‹æ‰ä¼šæˆåŠŸè°ƒç”¨ï¼Œè¿™ä¸ªæ˜¯ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šçš„

> [!TIP] è¿™é‡Œæˆ‘ç†è§£çš„æ˜¯ï¼Œâ€œé”â€ æ˜¯ä¸€ç§å¹¿æ³›çš„æ¦‚å¿µï¼Œå¯ä»¥æœ‰å¤šç§å®ç°æ–¹å¼ï¼Œc++ ä¸­çš„äº’æ–¥é‡ mutex å¯ä»¥ç”¨æ¥å®ç°é”

### `std::lock_guard`

ä¸€èˆ¬æ¥è¯´ï¼Œä¸å»ºè®®ç›´æ¥ä½¿ç”¨äº’æ–¥é‡ mutex æ˜¾å¼åœ°è¿›è¡Œ `lock()` å’Œ `unlock()`ã€‚å¯ä»¥ç”¨ C++11 æ ‡å‡†å¼•å…¥çš„ç®¡ç†ç±» `std::lock_guard`:

```cpp
void f() {
    std::lock_guard<std::mutex> lc{ m };  // ç­‰ä»·äº m.lock()ï¼Œè¶…å‡ºä½œç”¨åŸŸè°ƒç”¨ææ„æ¥ unlock
    std::cout << std::this_thread::get_id() << '\n';
}
```

`std::lock_guard` å®ç°æ¯”è¾ƒç®€å•ï¼Œå¯ä»¥çœ‹å®ƒåœ¨ [MSVC STL](https://github.com/microsoft/STL/blob/8dc4faadafb52e3e0a627e046b41258032d9bc6a/stl/inc/mutex#L448-L469) ä¸­çš„å®ç°ã€‚

> [!TIP] æˆ‘ä»¬è¦å°½å¯èƒ½çš„è®©äº’æ–¥é‡ä¸Šé”çš„**ç²’åº¦å°**ï¼Œåªç”¨æ¥ç¡®ä¿å¿…é¡»çš„å…±äº«èµ„æºçš„çº¿ç¨‹å®‰å…¨ã€‚
> â€œç²’åº¦â€é€šå¸¸ç”¨äºæè¿°é”å®šçš„èŒƒå›´å¤§å°ï¼Œè¾ƒå°çš„ç²’åº¦æ„å‘³ç€é”å®šçš„èŒƒå›´æ›´å°ï¼Œå› æ­¤æœ‰æ›´å¥½çš„æ€§èƒ½å’Œæ›´å°‘çš„ç«äº‰ã€‚

æ¯”å¦‚æœ‰çš„æ—¶å€™å¯ä»¥çœ‹åˆ°è¿™æ ·çš„å†™æ³•ï¼š

```cpp
void f() {
    //code..
    {
        std::lock_guard<std::mutex> lc{ m };
        // æ¶‰åŠå…±äº«èµ„æºçš„ä¿®æ”¹çš„ä»£ç ...
    }
    //code..
}
```

ä½¿ç”¨ `{}` åˆ›å»ºäº†ä¸€ä¸ªå—ä½œç”¨åŸŸï¼Œé™åˆ¶äº†å¯¹è±¡ `lc` çš„ç”Ÿå­˜æœŸï¼Œè¿›å…¥ä½œç”¨åŸŸæ„é€  `lock_guard` çš„æ—¶å€™ä¸Šé”ï¼ˆlockï¼‰ï¼Œç¦»å¼€ä½œç”¨åŸŸææ„çš„æ—¶å€™è§£é”ï¼ˆunlockï¼‰ã€‚

ä¸¾ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼š

```cpp
std::mutex m;

void add_to_list(int n, std::list<int>& list) {
    std::vector<int> numbers(n + 1);
    std::iota(numbers.begin(), numbers.end(), 0);  // iotaæ˜¯å¯¹vectorè¿›è¡Œé€’å¢ï¼ˆé»˜è®¤é€’å¢1ï¼‰èµ‹å€¼çš„æ–¹æ³•ï¼Œ0æ˜¯èµ·å§‹å€¼
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);  // 0æ˜¯èµ·å§‹å€¼

    {
        std::lock_guard<std::mutex> lc{ m };
        list.push_back(sum);
    }
}
void print_list(const std::list<int>& list){
    std::lock_guard<std::mutex> lc{ m };
    for(const auto& i : list){
        std::cout << i << ' ';
    }
    std::cout << '\n';
}

// ...... //

std::list<int> list;
std::thread t1{ add_to_list,i,std::ref(list) };  // ä¸Šé¢æåˆ°è¿‡ï¼Œä¼ å‚å³ä½¿æ˜¯å¼•ç”¨ï¼Œä¹Ÿä¼šè¢«å¤åˆ¶ï¼Œéœ€è¦ç”¨ std::ref
std::thread t2{ add_to_list,i,std::ref(list) };
std::thread t3{ print_list,std::cref(list) };  // const å¼•ç”¨éœ€è¦ç”¨ std::cref
std::thread t4{ print_list,std::cref(list) };
t1.join();
t2.join();
t3.join();
t4.join();
```

è¿™é‡Œçš„å…±äº«æ•°æ®åªæœ‰ `list`ï¼Œ å…ˆçœ‹ `add_to_list`ï¼Œåªæœ‰ `list.push_back(sum)` æ¶‰åŠåˆ°äº†å¯¹å…±äº«æ•°æ®çš„ä¿®æ”¹ï¼Œéœ€è¦è¿›è¡Œä¿æŠ¤ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ `{}` åŒ…è£¹ã€‚

å‡½æ•° `print_list()` æ‰“å° `list`ï¼Œç»™æ•´ä¸ªå‡½æ•°ä¸Šé”ï¼ŒåŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œã€‚æˆ‘ä»¬ä»£ç æ˜¯å¤šä¸ªçº¿ç¨‹æ‰§è¡Œè¿™ä¸¤ä¸ªå‡½æ•°ï¼Œä¸¤ä¸ªå‡½æ•°å…±äº«äº†ä¸€ä¸ªé”ï¼Œè¿™æ ·ç¡®ä¿äº†å½“æ‰§è¡Œå‡½æ•° `print_list()` æ‰“å°çš„æ—¶å€™ï¼Œ`list` çš„çŠ¶æ€æ˜¯ç¡®å®šçš„ã€‚æ‰“å°å‡½æ•° `print_list` å’Œ `add_to_list` å‡½æ•°çš„ä¿®æ”¹æ“ä½œåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œã€‚`print_list()` ä¸å¯èƒ½çœ‹åˆ°æ­£åœ¨è¢« `add_to_list()` ä¿®æ”¹çš„ `list`ã€‚

è‡³äºåˆ°åº•å“ªä¸ªå‡½æ•°å“ªä¸ªçº¿ç¨‹ä¼šå…ˆæ‰§è¡Œï¼Œæ‰§è¡Œå¤šå°‘æ¬¡ï¼Œè¿™äº›éƒ½ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šï¼Œä¹Ÿå®Œå…¨æœ‰å¯èƒ½è¿ç»­ 4 æ¬¡éƒ½æ˜¯æ‰§è¡Œå‡½æ•° `print_list` çš„çº¿ç¨‹æˆåŠŸè°ƒç”¨ `lock`ï¼Œä¼šæ‰“å°å‡ºäº†ä¸€æ ·çš„å€¼ï¼Œè¿™éƒ½å¾ˆæ­£å¸¸ã€‚

### `try_lock`

`try_lock` æ˜¯äº’æ–¥é‡ä¸­çš„ä¸€ç§å°è¯•ä¸Šé”çš„æ–¹å¼ã€‚ä¸å¸¸è§„çš„ `lock` ä¸åŒï¼Œ`try_lock` ä¼šå°è¯•ä¸Šé”ï¼Œä½†å¦‚æœé”å·²ç»è¢«å…¶ä»–çº¿ç¨‹å ç”¨ï¼Œåˆ™ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œè€Œæ˜¯ç«‹å³è¿”å›ã€‚

å®ƒçš„è¿”å›ç±»å‹æ˜¯ `bool` ï¼Œå¦‚æœä¸Šé”æˆåŠŸå°±è¿”å› `true`ï¼Œå¤±è´¥å°±è¿”å› `false`ã€‚

è¿™ç§æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å¾ˆæœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦ä¿æŠ¤ä¸´ç•ŒåŒºçš„åŒæ—¶ï¼Œåˆä¸æƒ³çº¿ç¨‹å› ä¸ºç­‰å¾…é”è€Œé˜»å¡çš„æƒ…å†µä¸‹ã€‚

```cpp
std::mutex mtx;

void thread_function(int id) {
    // å°è¯•åŠ é”
    if (mtx.try_lock()) {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å¾—é”" << std::endl;
        // ä¸´ç•ŒåŒºä»£ç 
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
        mtx.unlock(); // è§£é”
        std::cout << "çº¿ç¨‹ï¼š" << id << " é‡Šæ”¾é”" << std::endl;
    } else {
        std::cout << "çº¿ç¨‹ï¼š" << id << " è·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤" << std::endl;
    }
}
```
å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹è¿è¡Œè¿™æ®µä»£ç ï¼Œå¿…ç„¶æœ‰ä¸€ä¸ªçº¿ç¨‹æ— æ³•æˆåŠŸä¸Šé”ï¼Œè¦èµ° else çš„åˆ†æ”¯ã€‚

```cpp
std::thread t1(thread_function, 1);
std::thread t2(thread_function, 2);

t1.join();
t2.join();
```

å¯èƒ½çš„è¿è¡Œç»“æœï¼š
```text
çº¿ç¨‹ï¼š1 è·å¾—é”
çº¿ç¨‹ï¼š2 è·å–é”å¤±è´¥ å¤„ç†æ­¥éª¤
çº¿ç¨‹ï¼š1 é‡Šæ”¾é”
```

> [!CAUTION]
> åˆ‡å‹¿å°†å—ä¿æŠ¤æ•°æ®çš„æŒ‡é’ˆæˆ–å¼•ç”¨ä¼ é€’åˆ°äº’æ–¥é‡ä½œç”¨åŸŸä¹‹å¤–ï¼Œä¸ç„¶ä¿æŠ¤å°†å½¢åŒè™šè®¾ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“ä¾‹å­


```cpp
class Data {
    int a{};
    std::string b{};
public:
    void do_something() {
        // ä¿®æ”¹æ•°æ®æˆå‘˜ç­‰...
    }
};

class Data_wrapper {
    Data data;
    std::mutex m;
public:
    template<class Func>
    void process_data(Func func) {
        std::lock_guard<std::mutex> lc{m};
        func(data);  // å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å‡½æ•°
    }
};

Data* p = nullptr;

void malicious_function(Data& protected_data) {
    p = &protected_data; // å—ä¿æŠ¤çš„æ•°æ®è¢«ä¼ é€’åˆ°å¤–éƒ¨
}

Data_wrapper d;

void foo() {
    d.process_data(malicious_function);  // ä¼ é€’äº†ä¸€ä¸ªæ¶æ„çš„å‡½æ•°
    p->do_something();                   // åœ¨æ— ä¿æŠ¤çš„æƒ…å†µä¸‹è®¿é—®ä¿æŠ¤æ•°æ®
}
```

æˆå‘˜å‡½æ•°æ¨¡æ¿ `process_data` çœ‹èµ·æ¥ä¸€ç‚¹é—®é¢˜ä¹Ÿæ²¡æœ‰ï¼Œä½¿ç”¨ `std::lock_guard` å¯¹æ•°æ®åšäº†ä¿æŠ¤ï¼Œä½†æ˜¯è°ƒç”¨æ–¹ä¼ é€’äº† `malicious_function` è¿™æ ·ä¸€ä¸ªæ¶æ„çš„å‡½æ•°ï¼Œä½¿å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å¤–éƒ¨ï¼Œå¯ä»¥åœ¨æ²¡æœ‰è¢«äº’æ–¥é‡ä¿æŠ¤çš„æƒ…å†µä¸‹è°ƒç”¨ `do_something()`ã€‚

## æ­»é”ï¼šé—®é¢˜ä¸è§£å†³

_ä¸¤ä¸ªçº¿ç¨‹éœ€è¦å¯¹å®ƒä»¬æ‰€æœ‰çš„äº’æ–¥é‡åšä¸€äº›æ“ä½œï¼Œå…¶ä¸­æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªäº’æ–¥é‡ï¼Œä¸”ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹çš„äº’æ–¥é‡è§£é”ã€‚å› ä¸ºå®ƒä»¬éƒ½åœ¨ç­‰å¾…å¯¹æ–¹é‡Šæ”¾äº’æ–¥é‡ï¼Œæ²¡æœ‰çº¿ç¨‹å·¥ä½œã€‚ è¿™ç§æƒ…å†µå°±æ˜¯æ­»é”ã€‚==ä¸€èˆ¬åªæœ‰å¤šä¸ªäº’æ–¥é‡æ‰ä¼šé‡åˆ°æ­»é”é—®é¢˜==_

é¿å…æ­»é”çš„ä¸€èˆ¬å»ºè®®æ˜¯è®©ä¸¤ä¸ªäº’æ–¥é‡ä»¥ç›¸åŒçš„é¡ºåºä¸Šé”ï¼Œæ€»åœ¨äº’æ–¥é‡ B ä¹‹å‰é”ä½äº’æ–¥é‡ Aï¼Œå°±é€šå¸¸ä¸ä¼šæ­»é”ã€‚åé¢ç¤ºä¾‹ï¼š

```cpp
std::mutex m1,m2;
std::size_t n{};

void f() {
    std::lock_guard<std::mutex> lc1{ m1 };
    std::lock_guard<std::mutex> lc2{ m2 };
    ++n;
}
void f2() {
    std::lock_guard<std::mutex> lc1{ m2 };
    std::lock_guard<std::mutex> lc2{ m1 };
    ++n;
}
```

`f` ä¸ `f2` å› ä¸ºäº’æ–¥é‡ä¸Šé”é¡ºåºä¸åŒï¼Œå°±æœ‰æ­»é”é£é™©ã€‚å‡½æ•° `f` å…ˆé”å®š `m1`ï¼Œç„¶åå†å°è¯•é”å®š `m2`ï¼Œè€Œå‡½æ•° `f2` å…ˆé”å®š `m2` å†é”å®š `m1` ã€‚å¦‚æœä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡Œï¼Œå®ƒä»¬å°±å¯èƒ½ï¼ˆå…·ä½“è·å¾—é”çš„é¡ºåºç”±æ“ä½œç³»ç»Ÿè°ƒåº¦å†³å®šï¼Œä¸Šé¢é˜è¿°è¿‡ï¼‰ä¼šå½¼æ­¤ç­‰å¾…å¯¹æ–¹é‡Šæ”¾å…¶æ‰€éœ€çš„é”ï¼Œä»è€Œé€ æˆæ­»é”ã€‚

ä½†æœ‰æ—¶å€™å³ä½¿å›ºå®šäº†é”çš„é¡ºåºï¼Œä¾æ—§ä¼šäº§ç”Ÿé—®é¢˜ã€‚å½“æœ‰å¤šä¸ªäº’æ–¥é‡ä¿æŠ¤åŒä¸€ä¸ªç±»çš„å¯¹è±¡æ—¶ï¼Œå¯¹äºç›¸åŒç±»å‹çš„ä¸¤ä¸ªä¸åŒå¯¹è±¡è¿›è¡Œæ•°æ®çš„äº¤æ¢æ“ä½œï¼Œä¸ºäº†ä¿è¯æ•°æ®äº¤æ¢çš„æ­£ç¡®æ€§ï¼Œå°±è¦é¿å…å…¶å®ƒçº¿ç¨‹ä¿®æ”¹ï¼Œç¡®ä¿æ¯ä¸ªå¯¹è±¡çš„äº’æ–¥é‡éƒ½é”ä½è‡ªå·±è¦ä¿æŠ¤çš„åŒºåŸŸã€‚å¦‚æœæŒ‰ç…§å‰é¢çš„çš„é€‰æ‹©ä¸€ä¸ªå›ºå®šçš„é¡ºåºä¸Šé”è§£é”ï¼Œåˆ™æ¯«æ— æ„ä¹‰ï¼Œæ¯”å¦‚ï¼š

```cpp
struct X {
    X(const std::string& str) :object{ str } {}

    friend void swap(X& lhs, X& rhs);
private:
    std::string object;
    std::mutex m;
};

void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::lock_guard<std::mutex> lock1{ lhs.m };
    std::lock_guard<std::mutex> lock2{ rhs.m };
    swap(lhs.object, rhs.object);
}
```

è€ƒè™‘ç”¨æˆ·è°ƒç”¨çš„æ—¶å€™å°†å‚æ•°äº¤æ¢ï¼Œå°±ä¼šäº§ç”Ÿæ­»é”ï¼š

```cpp
X a{ "ğŸ¤£" }, b{ "ğŸ˜…" };
std::thread t{ [&] {swap(a, b); } };  // 1
std::thread t2{ [&] {swap(b, a); } }; // 2
```

`1` æ‰§è¡Œçš„æ—¶å€™ï¼Œå…ˆä¸Šé” a çš„äº’æ–¥é‡ï¼Œå†ä¸Šé” b çš„äº’æ–¥é‡ã€‚

`2` æ‰§è¡Œçš„æ—¶å€™ï¼Œå…ˆä¸Šé” b çš„äº’æ–¥é‡ï¼Œå†ä¸Šé” a çš„äº’æ–¥é‡ã€‚

> å®Œå…¨å¯èƒ½çº¿ç¨‹ A æ‰§è¡Œ 1 çš„æ—¶å€™ä¸Šé”äº† a çš„äº’æ–¥é‡ï¼Œçº¿ç¨‹ B æ‰§è¡Œ 2 ä¸Šé”äº† b çš„äº’æ–¥é‡ã€‚çº¿ç¨‹ A å¾€ä¸‹æ‰§è¡Œéœ€è¦ä¸Šé” b çš„äº’æ–¥é‡ï¼Œçº¿ç¨‹ B åˆ™è¦ä¸Šé” a çš„äº’æ–¥é‡æ‰§è¡Œå®Œæ¯•æ‰èƒ½è§£é”ï¼Œå“ªä¸ªéƒ½æ²¡åŠæ³•å¾€ä¸‹æ‰§è¡Œï¼Œæ­»é”ã€‚

å¦‚ä½•è§£å†³ï¼Ÿå¯ä»¥ä½¿ç”¨ C++ æ ‡å‡†åº“ä¸­çš„ `std::lock`ï¼Œå®ƒèƒ½ä¸€æ¬¡æ€§é”ä½å¤šä¸ªäº’æ–¥é‡ï¼Œå¹¶ä¸”æ²¡æœ‰æ­»é”é£é™©ã€‚ä¿®æ”¹å `swap` ä»£ç å¦‚ä¸‹ï¼š
```cpp
void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::lock(lhs.m, rhs.m);    // ç»™ä¸¤ä¸ªäº’æ–¥é‡ä¸Šé”
    std::lock_guard<std::mutex> lock1{ lhs.m,std::adopt_lock };
    std::lock_guard<std::mutex> lock2{ rhs.m,std::adopt_lock };
    swap(lhs.object, rhs.object);
}
```
å› ä¸ºå‰é¢å·²ç»ä½¿ç”¨äº† `std::lock` ä¸Šé”ï¼Œæ‰€ä»¥åé¢çš„ `std::lock_guard` æ„é€ éƒ½é¢å¤–ä¼ é€’äº†ä¸€ä¸ª `std::adopt_lock` å‚æ•°ï¼Œè®©å…¶é€‰æ‹©åˆ°ä¸ä¸Šé”çš„æ„é€ å‡½æ•°ã€‚å‡½æ•°é€€å‡ºä¹Ÿèƒ½æ­£å¸¸è§£é”ã€‚

`std::lock` ç»™ `lhs.m` æˆ– `rhs.m` ä¸Šé”æ—¶è‹¥æŠ›å‡ºå¼‚å¸¸ï¼Œåˆ™åœ¨é‡æŠ›å‰å¯¹ä»»ä½•å·²é”çš„å¯¹è±¡è°ƒç”¨ `unlock()` è§£é”ï¼Œä¹Ÿå°±æ˜¯ `std::lock` è¦ä¹ˆå°†äº’æ–¥é‡éƒ½ä¸Šé”ï¼Œè¦ä¹ˆä¸€ä¸ªéƒ½ä¸é”ã€‚

C++17 æ–°å¢äº† `std::scoped_lock` ï¼Œæä¾›æ­¤å‡½æ•°çš„ RAII åŒ…è£…ï¼Œé€šå¸¸å®ƒæ¯”è£¸è°ƒç”¨ `std::lock` æ›´å¥½ã€‚

æ‰€ä»¥æˆ‘ä»¬å‰é¢çš„ä»£ç å¯ä»¥æ”¹å†™ä¸ºï¼š
```cpp
void swap(X& lhs, X& rhs) {
    if (&lhs == &rhs) return;
    std::scoped_lock guard{ lhs.m,rhs.m };
    swap(lhs.object, rhs.object);
}
```

ä½¿ç”¨ `std::scoped_lock` å¯ä»¥å°†æ‰€æœ‰ `std::lock` æ›¿æ¢æ‰ï¼Œå‡å°‘é”™è¯¯å‘ç”Ÿã€‚ä¹Ÿå¯ä»¥ç”¨ `std::unique_lock`ï¼ˆå¯ä»¥ç®€å•ç†è§£ä¸º `std::lock_guard` çš„å‡çº§ç‰ˆï¼Œå…·æœ‰é¢å¤–çš„åŠŸèƒ½ï¼Œä¸ºæ›´å¤æ‚çš„é”åšå‡†å¤‡ï¼‰ï¼Œè¯¦æƒ…è§æ ‡å‡†åº“æ–‡æ¡£ã€‚

æ€»ç»“ï¼Œé¿å…æ­»é”è¦æ³¨æ„ï¼š

1. é¿å…åµŒå¥—é”ï¼šçº¿ç¨‹è·å–ä¸€ä¸ªé”æ—¶ï¼Œå°±åˆ«å†è·å–ç¬¬äºŒä¸ªé”ã€‚æ¯ä¸ªçº¿ç¨‹åªæŒæœ‰ä¸€ä¸ªé”ï¼Œè‡ªç„¶ä¸ä¼šäº§ç”Ÿæ­»é”ã€‚å¦‚æœå¿…é¡»è¦è·å–å¤šä¸ªé”ï¼Œä½¿ç”¨ `std::lock`ã€‚
2. é¿å…åœ¨æŒæœ‰é”æ—¶è°ƒç”¨å¤–éƒ¨ä»£ç 
3. ä½¿ç”¨å›ºå®šé¡ºåºè·å–é”

## è¯»å†™é”

å¦‚æœéœ€è¦å¤šçº¿ç¨‹è¯»å–å†™ï¼ˆå¤šçº¿ç¨‹è¯»ä¸å­˜åœ¨æ•°æ®ç«äº‰ï¼›è€Œå†™å’Œè¯»å…±å­˜æ—¶å­˜åœ¨ç«äº‰ï¼‰ï¼Œä½¿ç”¨ `std::mutex` å¼€é”€è¾ƒå¤§ã€‚è¿™æ—¶å¯ä»¥ç”¨ä¸“é—¨çš„è¯»å†™é”ï¼Œå³ `std::shared_timed_mutex` (C++ 14)ï¼Œ`std::shared_mutex` (C++ 17)ã€‚ç¤ºä¾‹ä»£ç ï¼š

```cpp
class Settings {
private:
    std::map<std::string, std::string> data_;
    mutable std::shared_mutex mutex_; // â€œM&M è§„åˆ™â€ï¼šmutable ä¸ mutex ä¸€èµ·å‡ºç°

public:
    void set(const std::string& key, const std::string& value) {
        std::lock_guard<std::shared_mutex> lock{ mutex_ };
        data_[key] = value;
    }

    std::string get(const std::string& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        auto it = data_.find(key);
        return (it != data_.end()) ? it->second : ""; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é”®è¿”å›ç©ºå­—ç¬¦ä¸²
    }
};
```

###  ä½¿ç”¨äº’æ–¥é‡å®ç°å¹¶å‘è¯»å†™é”ï¼ˆå­—èŠ‚ DataAML ä¸€é¢æ‰‹æ’•é¢˜ï¼‰

æˆ‘ä»¬çŸ¥é“ï¼Œ==å†™æ“ä½œæ˜¯ç‹¬å çš„==ï¼›è€Œ==è¯»æ“ä½œæ˜¯éç‹¬å çš„==ï¼Œå³å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»ã€‚å¦‚æœå¤šçº¿ç¨‹è®¿é—®æŸä¸ªå…±äº«å˜é‡æ—¶ï¼Œæ¯æ¬¡è®¿é—®æ—¶éƒ½åŠ ä¸Šä¸€ä¸ªäº’æ–¥é”ï¼Œè¿™æ ·å¼€é”€ä¼šéå¸¸å¤§ã€‚

> [!TIP] æ‰€ä»¥æˆ‘ä»¬æœŸæœ›åœ¨å¤šä¸ªçº¿ç¨‹è¯•å›¾è¯»å–å…±äº«å˜é‡çš„æ—¶å€™ï¼Œå®ƒä»¬å¯ä»¥ç«‹åˆ»è·å–å› ä¸ºè¯»è€ŒåŠ çš„é”ï¼Œè€Œä¸æ˜¯éœ€è¦ç­‰å¾…å‰ä¸€ä¸ªçº¿ç¨‹é‡Šæ”¾ã€‚å½“ç„¶ï¼Œå¦‚æœä¸€ä¸ªçº¿ç¨‹ç”¨å†™é”é”ä½äº†ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆå…¶ä»–çº¿ç¨‹æ— è®ºæ˜¯è¯»è¿˜æ˜¯å†™éƒ½ä¼šå‘ç”Ÿé˜»å¡ã€‚

![Image](https://github.com/user-attachments/assets/6e5ce148-7456-457b-b1d1-c26f11c82ad5)

```cpp
#include <iostream>
#include <mutex>
#include <thread>

class ReadWriteLock {
private:
    std::mutex readMutex;     // ç”¨äºä¿æŠ¤è¯»æ“ä½œè®¡æ•°å™¨çš„äº’æ–¥é‡
    std::mutex writeMutex;    // ç”¨äºä¿æŠ¤å†™æ“ä½œçš„äº’æ–¥é‡
    int readCount = 0;        // è®°å½•å½“å‰æ­£åœ¨è¿›è¡Œè¯»æ“ä½œçš„çº¿ç¨‹æ•°é‡
    bool writing = false;     // è¡¨ç¤ºå½“å‰æ˜¯å¦æœ‰çº¿ç¨‹æ­£åœ¨è¿›è¡Œå†™æ“ä½œ

public:
    void readLock() {
        // é”å®šè¯»æ“ä½œäº’æ–¥é‡
        std::unique_lock<std::mutex> readLock(readMutex);

        // å¢åŠ è¯»æ“ä½œè®¡æ•°å™¨
        ++ readCount;

        // ç­‰å¾…æ²¡æœ‰å†™æ“ä½œæ—¶è¿›è¡Œè¯»æ“ä½œ
        while (writing) {
            readLock.unlock();
            std::this_thread::yield();  // è®©å‡ºCPUï¼Œé¿å…å¿™ç­‰å¾…
            readLock.lock();
        }
    }

    void readUnlock() {
        // é”å®šè¯»æ“ä½œäº’æ–¥é‡å¹¶å‡å°‘è¯»æ“ä½œè®¡æ•°å™¨
        std::lock_guard<std::mutex> readLock(readMutex);
        -- readCount;
    }

    void writeLock() {
        // é”å®šå†™æ“ä½œäº’æ–¥é‡
        std::unique_lock<std::mutex> writeLock(writeMutex);

        // ç­‰å¾…æ²¡æœ‰è¯»æ“ä½œå’Œå†™æ“ä½œæ—¶è¿›è¡Œå†™æ“ä½œ
        while (readCount > 0 || writing) {
            writeLock.unlock();
            std::this_thread::yield();  // è®©å‡ºCPUï¼Œé¿å…å¿™ç­‰å¾…
            writeLock.lock();
        }

        // æ ‡è®°æ­£åœ¨è¿›è¡Œå†™æ“ä½œ
        writing = true;
    }

    void writeUnlock() {
        // é”å®šå†™æ“ä½œäº’æ–¥é‡å¹¶æ ‡è®°å†™æ“ä½œå®Œæˆ
        std::lock_guard<std::mutex> writeLock(writeMutex);
        writing = false;
    }
};

// ç¤ºä¾‹ä½¿ç”¨
int sharedData = 0;
ReadWriteLock lock;

void reader() {
    lock.readLock();
    std::cout << "Reading: " << sharedData << std::endl;
    lock.readUnlock();
}

void writer() {
    lock.writeLock();
    ++ sharedData;
    std::cout << "Writing: " << sharedData << std::endl;
    lock.writeUnlock();
}

int main() {
    std::thread readers[5];
    std::thread writers[3];

    // åˆ›å»ºå¤šä¸ªè¯»çº¿ç¨‹å’Œå†™çº¿ç¨‹
    for (int i = 0; i < 5; ++i) {
        readers[i] = std::thread(reader);
    }
    for (int i = 0; i < 3; ++i) {
        writers[i] = std::thread(writer);
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    for (auto& reader : readers) {
        reader.join();
    }
    for (auto& writer : writers) {
        writer.join();
    }

    return 0;
}
```

è¿™æ®µä»£ç ä¸­ï¼Œé”å®šæ“ä½œç”¨çš„æ˜¯ `std::unique_lock`ï¼Œè€Œè§£é”æ“ä½œç”¨çš„æ˜¯ `std::lock_guard`ã€‚è¿™ä¸¤è€…éƒ½æ˜¯ C++ 11 å¼•å…¥çš„ RAII åŒ…è£…ã€‚æ­£å¦‚ä¸Šé¢æ‰€è¿°ï¼Œ`unique_lock` æ˜¯ `lock_guard` çš„å‡çº§ç‰ˆ ==ï¼ˆæ›´çµæ´»ï¼Œå¸¸ä¸æ¡ä»¶å˜é‡çš„ `wait()`ã€`notify_one()`ã€`notify_all()`é…åˆä½¿ç”¨ï¼‰==ï¼Œè¿™é‡Œé”å®šæ—¶éœ€è¦è§£é”å’Œé‡æ–°é”å®šäº’æ–¥é‡ã€‚è¿™å¯¹äºéœ€è¦åœ¨ç­‰å¾…æ¡ä»¶æ»¡è¶³æ—¶è§£é”äº’æ–¥é‡å¹¶è®©å‡º CPU çš„åœºæ™¯éå¸¸æœ‰ç”¨ã€‚
